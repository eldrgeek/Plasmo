/**
 * PLASMO CHROME EXTENSION REPOSITORY CONTEXT
 * 
 * This file contains the complete source code and documentation for the Plasmo
 * Chrome Extension project with integrated MCP (Model Context Protocol) server.
 * 
 * Repository Information:
 * - GitHub URL: https://github.com/eldrgeek/Plasmo.git
 * - Local Path: /Users/MikeWolf/Projects/Plasmo
 * - Generated: Sun Jun  8 12:00:10 EDT 2025
 * - Generated by: generate_llm_context.sh
 * 
 * Project Description:
 * This is a Plasmo browser extension project with an integrated MCP server for 
 * Chrome Debug Protocol integration. The MCP server enables real-time debugging 
 * and monitoring of the extension through AI assistance.
 * 
 * Key Technologies:
 * - Plasmo: Browser extension framework
 * - TypeScript/React: Extension UI and logic  
 * - Python FastMCP: MCP server for Chrome debugging
 * - Chrome Debug Protocol: Browser automation and debugging
 * - WebSocket: Real-time communication with browser
 * 
 * Structure:
 * 1. Cursor Rules (Development Guidelines)
 * 2. Core Extension Files
 * 3. MCP Server Implementation
 * 4. Configuration Files
 * 5. Documentation
 * 6. Supporting Scripts
 */


=================================================================================
= CURSOR RULES - DEVELOPMENT GUIDELINES
=================================================================================


### File: .cursorrules
### Description: Main cursor rules file
### Lines:       58
### Size: 4.0K

```text
# Cursor Rules for Plasmo Extension Development with MCP Server

## Project Context
This is a Plasmo browser extension project with an integrated MCP (Model Context Protocol) server for Chrome Debug Protocol integration. The MCP server enables real-time debugging and monitoring of the extension through AI assistance.

## Key Technologies
- **Plasmo**: Browser extension framework
- **TypeScript/React**: Extension UI and logic
- **Python FastMCP**: MCP server for Chrome debugging
- **Chrome Debug Protocol**: Browser automation and debugging
- **WebSocket**: Real-time communication with browser

## Development Guidelines

### MCP Server Development
- Always ensure return values from MCP tools are JSON-serializable (no complex objects)
- Use `make_json_safe()` helper for converting objects to basic types
- Handle Chrome Debug Protocol WebSocket connections carefully
- **CRITICAL: Chrome Debug Protocol requires INTEGER request IDs, not strings**
- Use `int(time.time() * 1000000) % 1000000` for Chrome Debug Protocol request IDs
- Test Chrome flag compatibility when adding new debugging features
- Remember that extension service worker IDs change on Chrome restart

### Chrome Debugging Setup
- Use `./launch-chrome-debug.sh` script for proper Chrome configuration
- Required flags: `--remote-debugging-port=9222 --remote-allow-origins=*`
- Extension debugging requires special WebSocket origin permissions
- Monitor console logs through MCP server tools, not direct WebSocket connections

### Code Organization
- Keep MCP server tools focused and single-purpose
- Document Chrome Debug Protocol interactions thoroughly
- Maintain separation between extension code and debugging infrastructure
- Use proper error handling for WebSocket connections

### File Management
- Never commit `__pycache__/`, `mcp_server.log`, or Chrome profile contents
- Keep `chrome-debug-profile/` directory structure but ignore contents
- Document any new MCP tools in relevant README files

### Extension Development
- Test extension functionality both standalone and through MCP debugging
- Verify auto-reload functionality works with file changes
- Use MCP server console monitoring for debugging extension logic
- Maintain compatibility between extension and debugging infrastructure

### Best Practices
- Test MCP server tools thoroughly before committing
- Handle serialization edge cases proactively
- Document Chrome version compatibility for debugging features
- Keep debugging tools separate from production extension code
- Use parallel tool calls when gathering multiple pieces of information

## Common Issues & Solutions
- **Serialization errors**: Convert objects to dict/list/string before returning
- **WebSocket 403 errors**: Ensure `--remote-allow-origins=*` flag is set
- **Chrome Debug Protocol "integer id" error**: Use integer request IDs, not strings
- **Extension not found**: Check service worker is running and ID is current
- **MCP tools not available**: Restart Cursor after server changes 
```


### File: .cursor/rules/ai-assistant-instructions.mdc
### Description: Cursor rule: ai-assistant-instructions
### Lines:      196
### Size: 8.0K

```markdown
---
description: "Instructions for AI assistant to effectively use cursor rules and MCP capabilities"
alwaysApply: true
---

# AI Assistant Operating Instructions

## Rule System Integration
As an AI assistant with MCP access, I should actively reference and follow the established cursor rules:

### Core Workflow
1. **Read Current Rules**: Always check existing `.cursor/rules/*.mdc` files before providing advice
2. **Follow Established Patterns**: Adhere to patterns defined in the project's cursor rules
3. **Use MCP Capabilities**: Leverage MCP server tools for hands-on analysis and implementation
4. **Update Rules**: Suggest updates to rules based on discovered patterns or improvements

### Rule Categories to Reference
- **core-architecture.mdc**: Project structure and Chrome extension patterns
- **typescript-react-standards.mdc**: Code quality and React patterns
- **testing-strategy.mdc**: Testing approach and implementation
- **planning-methodology.mdc**: Project planning and agile practices
- **specification-standards.mdc**: Documentation and API standards
- **retrospectives-improvement.mdc**: Continuous improvement processes
- **mcp-server-standards.mdc**: MCP server development patterns
- **chrome-debug-integration.mdc**: Debug protocol usage patterns
- **ai-assisted-development.mdc**: AI-enhanced development workflows

## MCP Tool Usage Strategy

### Code Analysis Workflow
```typescript
// When analyzing code issues:
async function analyzeCodeIssue(issue: string) {
  // 1. Read project structure
  const structure = await get_project_structure();
  
  // 2. Search for related code
  const relatedFiles = await search_in_files(issue);
  
  // 3. Read relevant files
  const fileContents = await Promise.all(
    relatedFiles.map(file => read_file(file.path))
  );
  
  // 4. Analyze with cursor rules context
  const analysis = analyzeWithRulesContext(fileContents, issue);
  
  // 5. Use Chrome debug if needed
  if (requiresDebug(issue)) {
    await launchChromeDebug();
    const debugData = await performDebugAnalysis(issue);
    analysis.debugInsights = debugData;
  }
  
  return analysis;
}
```

### Development Assistance Pattern
```typescript
// When providing development assistance:
async function provideDevelopmentAssistance(request: string) {
  // 1. Understand current context
  const projectStructure = await get_project_structure();
  const currentFiles = await list_files(".", "*.{ts,tsx,js,jsx}", true);
  
  // 2. Reference applicable cursor rules
  const applicableRules = await identifyApplicableRules(request);
  
  // 3. Analyze existing patterns
  const codePatterns = await analyzeExistingPatterns(currentFiles);
  
  // 4. Generate contextual response
  const response = generateContextualResponse({
    request,
    projectStructure,
    rules: applicableRules,
    patterns: codePatterns
  });
  
  // 5. Provide implementation if requested
  if (request.includes("implement") || request.includes("create")) {
    const implementation = await generateImplementation(response);
    await write_file(implementation.path, implementation.content);
  }
  
  return response;
}
```

### Debug Session Management
```typescript
// When debugging is required:
async function manageDebugSession(issue: string) {
  try {
    // 1. Start debug session
    await launch_chrome_debug();
    const connection = await connect_to_chrome();
    
    // 2. Set up monitoring
    await start_console_monitoring(connection.tabs[0].id);
    
    // 3. Execute debug workflow
    const debugData = await executeDebugWorkflow(issue);
    
    // 4. Analyze results
    const analysis = await analyzeDebugResults(debugData);
    
    // 5. Generate actionable insights
    return generateDebugReport(analysis);
    
  } finally {
    // Always clean up
    await clear_console_logs();
  }
}
```

## Response Generation Guidelines

### Code Suggestions
When providing code suggestions:
1. **Check cursor rules** for established patterns
2. **Analyze existing code** to match style and architecture
3. **Consider Chrome extension context** (popup, background, content script)
4. **Include proper TypeScript types** following project standards
5. **Add appropriate tests** following testing strategy
6. **Consider performance implications** as outlined in rules

### Problem Solving Approach
1. **Understand the Problem**: Use MCP tools to analyze the current state
2. **Reference Standards**: Check cursor rules for applicable patterns
3. **Analyze Context**: Consider the broader codebase and architecture
4. **Propose Solutions**: Offer multiple approaches with trade-offs
5. **Implement if Requested**: Use MCP tools to make actual changes
6. **Validate Results**: Test and verify implementations

### Communication Style
- **Be Specific**: Reference exact files, line numbers, and functions
- **Explain Reasoning**: Connect suggestions to cursor rules and project patterns
- **Provide Context**: Explain how changes fit into the broader architecture
- **Offer Alternatives**: Present multiple solutions when applicable
- **Document Changes**: Explain what was changed and why

## Continuous Improvement
1. **Learn from Interactions**: Note successful patterns and common issues
2. **Update Rules**: Suggest improvements to cursor rules based on experience
3. **Refine Processes**: Optimize MCP tool usage based on outcomes
4. **Share Knowledge**: Document discoveries and improvements

## Error Handling and Recovery
```typescript
// Robust error handling for MCP operations:
async function robustMCPOperation<T>(operation: () => Promise<T>): Promise<T> {
  try {
    return await operation();
  } catch (error) {
    // Log error with context
    console.error(`MCP operation failed:`, error);
    
    // Attempt recovery based on error type
    if (error.message.includes('file not found')) {
      // Handle missing files
      const alternatives = await findAlternativeFiles();
      return await retryWithAlternatives(operation, alternatives);
    }
    
    if (error.message.includes('permission denied')) {
      // Handle permission issues
      await adjustPermissions();
      return await operation();
    }
    
    // If recovery fails, provide helpful error context
    throw new Error(`Operation failed: ${error.message}. Consider checking file paths and permissions.`);
  }
}
```

## Integration Checklist
Before providing any substantial code assistance:
- [ ] Read relevant cursor rule files
- [ ] Analyze current project structure
- [ ] Check existing code patterns
- [ ] Consider Chrome extension architecture
- [ ] Validate against TypeScript standards
- [ ] Ensure testing strategy compliance
- [ ] Use Chrome debug protocol if needed
- [ ] Document reasoning and trade-offs

## Success Metrics
- **Consistency**: Suggestions align with established patterns
- **Efficiency**: Use MCP tools to minimize manual work
- **Quality**: Generated code passes all checks and standards
- **Learning**: Continuously improve based on outcomes
- **Integration**: Changes fit seamlessly into existing codebase

```


### File: .cursor/rules/ai-assisted-development.mdc
### Description: Cursor rule: ai-assisted-development
### Lines:      368
### Size:  16K

```markdown
---
description: "AI-assisted coding patterns leveraging MCP server capabilities"
globs: ["**/*.ts", "**/*.tsx", "**/*.py"]
alwaysApply: false
---
# AI-Assisted Development Workflows v2.0

## MCP Server Knowledge Injection - CRITICAL REQUIREMENT

### ⚠️ MANDATORY: MCP Server Context Awareness
**IMPORTANT**: Every conversation using MCP tools must inject comprehensive server knowledge:

```typescript
interface MCPServerContext {
  version: "2.0.0-consolidated";
  serverFile: "mcp_server.py";
  deprecatedFiles: [
    "mcp_server.py",
    "mcp_server_fixed.py", 
    "mcp_server_backup.py",
    "mcp_server_v1.1.1_unicode_fix.py"
  ];
  capabilities: {
    fileOperations: "secure_with_path_validation";
    codeAnalysis: "comprehensive_metrics_and_complexity";
    gitIntegration: "read_only_with_command_filtering";
    chromeDebugging: "real_time_with_robust_error_handling";
    consoleMonitoring: "persistent_websocket_connections";
    javascriptExecution: "async_with_proper_correlation";
    breakpointManagement: "intelligent_conditional_support";
    errorHandling: "comprehensive_with_structured_logging";
    resourceManagement: "automatic_cleanup_and_tracking";
    securityFeatures: "path_traversal_protection_and_input_sanitization";
    unicodeSupport: "emoji_and_special_character_safe";
    threadSafety: "connection_locking_and_synchronization";
  };
  architecture: {
    transport: "HTTP";
    async_support: true;
    websocket_management: "context_managed";
    logging: "structured_with_file_and_console";
    error_recovery: "automatic_with_fallbacks";
    resource_cleanup: "signal_handlers_and_atexit";
  };
}
```

### Knowledge Injection Requirements
When any MCP server tool is used, the AI assistant MUST be aware of:

1. **Server Architecture**: Consolidated v2.0 with unified codebase
2. **Security Model**: Path validation, input sanitization, size limits
3. **Error Handling**: Comprehensive with logging and structured responses
4. **Chrome Debugging**: WebSocket-based with proper async correlation
5. **Resource Management**: Connection tracking and automatic cleanup
6. **Performance Features**: Caching, async operations, timeout handling

## Enhanced MCP Tool Usage Patterns

### Secure File Operations Workflow
```typescript
// Always use with security awareness
async function secureFileWorkflow(issue: string) {
  // 1. Validate file access is within project boundaries
  const projectStructure = await get_project_structure(".", 3);
  
  // 2. Use enhanced search with security filtering
  const searchResults = await search_in_files(issue, ".", "*.{ts,tsx,py}", false);
  
  // 3. Read files with automatic backup and validation
  const fileContents = await Promise.all(
    searchResults.matches.map(match => read_file(match.file))
  );
  
  // 4. Analyze with comprehensive metrics
  const codeAnalysis = await Promise.all(
    searchResults.matches.map(match => analyze_code(match.file))
  );
  
  return { projectStructure, searchResults, fileContents, codeAnalysis };
}
```

### Chrome Debugging Workflow v2.0
```typescript
// Enhanced debugging with robust error handling
async function chromeDebugWorkflow(issue: string) {
  try {
    // 1. Launch Chrome with enhanced multi-platform support
    const launchResult = await launch_chrome_debug();
    if (!launchResult.success) {
      throw new Error(`Chrome launch failed: ${launchResult.error}`);
    }
    
    // 2. Connect with enhanced connection management
    const connection = await connect_to_chrome(9222, "localhost");
    if (!connection.success) {
      throw new Error(`Chrome connection failed: ${connection.error}`);
    }
    
    // 3. Get tabs with intelligent filtering
    const tabs = await get_chrome_tabs(connection.connection_id);
    const extensionTabs = tabs.tabs.filter(tab => tab.is_extension);
    
    // 4. Start real-time console monitoring
    for (const tab of extensionTabs) {
      const monitorResult = await start_console_monitoring_fixed(
        tab.id, 
        connection.connection_id
      );
      
      if (monitorResult.success) {
        console.log(`Console monitoring started for ${tab.title}`);
      }
    }
    
    // 5. Execute diagnostic JavaScript with proper error handling
    const diagnosticCode = generateDiagnosticCode(issue);
    const executionResults = await Promise.all(
      extensionTabs.map(tab => 
        execute_javascript_fixed(diagnosticCode, tab.id, connection.connection_id)
      )
    );
    
    // 6. Analyze console logs with structured filtering
    const consoleLogs = await get_console_logs(
      null, 
      connection.connection_id, 
      100
    );
    
    return {
      launch: launchResult,
      connection: connection,
      tabs: tabs,
      execution: executionResults,
      console: consoleLogs,
      analysis: analyzeDebugResults(executionResults, consoleLogs)
    };
    
  } catch (error) {
    return {
      success: false,
      error: error.message,
      suggestion: "Check Chrome launch configuration and debugging setup"
    };
  }
}
```

### Error-Aware Development Assistance
```typescript
// Always expect and handle comprehensive error responses
async function handleMCPOperation<T>(operation: () => Promise<T>): Promise<T> {
  try {
    const result = await operation();
    
    // Check for structured error responses
    if (typeof result === 'object' && result !== null && 'success' in result) {
      if (!result.success) {
        console.error(`MCP Operation Error:`, {
          operation: result.operation || 'unknown',
          error: result.error,
          errorType: result.error_type,
          timestamp: result.timestamp,
          context: result.context
        });
        
        // Provide contextual recovery suggestions
        if (result.error_type === 'FileNotFoundError') {
          console.log('Suggestion: Check file path and ensure file exists');
        } else if (result.error_type === 'PermissionError') {
          console.log('Suggestion: Check file permissions and access rights');
        } else if (result.error_type === 'UnicodeDecodeError') {
          console.log('Suggestion: File may contain binary data or invalid encoding');
        }
        
        throw new Error(`MCP operation failed: ${result.error}`);
      }
    }
    
    return result;
  } catch (error) {
    console.error('MCP operation exception:', error);
    throw error;
  }
}
```

## Context-Aware Problem Solving

### Issue Analysis with MCP Context
```typescript
interface IssueAnalysisContext {
  mcpServer: MCPServerContext;
  projectType: "plasmo_chrome_extension";
  availableTools: string[];
  securityConstraints: string[];
  debuggingCapabilities: string[];
}

async function analyzeIssueWithContext(
  issue: string, 
  context: IssueAnalysisContext
): Promise<AnalysisResult> {
  
  // 1. Understand issue scope with enhanced tools
  const projectAnalysis = await get_project_structure(".", 4);
  const codeSearch = await search_in_files(issue, ".", "*.{ts,tsx,js,jsx,py}", false);
  
  // 2. Use Chrome debugging if relevant
  let chromeAnalysis = null;
  if (issue.includes('chrome') || issue.includes('extension') || issue.includes('browser')) {
    chromeAnalysis = await chromeDebugWorkflow(issue);
  }
  
  // 3. Analyze git context safely
  const gitStatus = await run_git_command("status", ".");
  const gitLog = await run_git_command("log --oneline -10", ".");
  
  // 4. Get comprehensive system context
  const systemInfo = await get_system_info(false); // Privacy-aware
  const serverInfo = await server_info();
  
  return {
    issue: issue,
    project: projectAnalysis,
    codeMatches: codeSearch,
    chrome: chromeAnalysis,
    git: { status: gitStatus, log: gitLog },
    system: systemInfo,
    server: serverInfo,
    recommendations: generateRecommendations(issue, {
      project: projectAnalysis,
      code: codeSearch,
      chrome: chromeAnalysis
    })
  };
}
```

### Solution Implementation with MCP Integration
```typescript
async function implementSolutionWithMCP(
  solution: SolutionPlan,
  context: IssueAnalysisContext
): Promise<ImplementationResult> {
  
  const results = [];
  
  for (const step of solution.steps) {
    try {
      switch (step.type) {
        case 'file_modification':
          // Use secure file operations with backup
          const backupResult = await read_file(step.filePath);
          const writeResult = await write_file(step.filePath, step.content);
          results.push({ step, result: writeResult, backup: backupResult });
          break;
          
        case 'chrome_debugging':
          // Use enhanced Chrome debugging workflow
          const debugResult = await chromeDebugWorkflow(step.issue);
          results.push({ step, result: debugResult });
          break;
          
        case 'code_analysis':
          // Use comprehensive code analysis
          const analysisResult = await analyze_code(step.filePath);
          results.push({ step, result: analysisResult });
          break;
          
        case 'git_operation':
          // Use safe git commands only
          const gitResult = await run_git_command(step.command, ".");
          results.push({ step, result: gitResult });
          break;
      }
    } catch (error) {
      results.push({
        step,
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  return {
    solution: solution,
    results: results,
    success: results.every(r => !r.error),
    timestamp: new Date().toISOString()
  };
}
```

## Knowledge Transfer and Learning

### MCP Server Capability Awareness
The AI assistant must demonstrate understanding of:

1. **Enhanced Security**: All file operations include path validation and size limits
2. **Robust Error Handling**: Every operation returns structured error responses
3. **Chrome Debug Integration**: Real-time monitoring with proper WebSocket management
4. **Resource Management**: Automatic cleanup of connections and background tasks
5. **Unicode Safety**: Proper handling of emoji and special characters in all outputs
6. **Thread Safety**: Concurrent operation support with proper synchronization

### Communication Patterns
When discussing MCP server capabilities:

```typescript
// ✅ CORRECT: Demonstrate awareness of v2.0 capabilities
"I'll use the consolidated MCP server's enhanced file operations which include 
automatic path validation and backup creation. The server's comprehensive error 
handling will provide structured responses if any issues occur."

// ❌ INCORRECT: Reference deprecated functionality
"I'll use the mcp_server.py file operations..." // Wrong - deprecated file

// ✅ CORRECT: Show understanding of Chrome debugging improvements
"The consolidated server's Chrome debugging uses persistent WebSocket connections 
with proper request/response correlation, ensuring reliable JavaScript execution 
and real-time console monitoring."

// ❌ INCORRECT: Ignore error handling improvements
"I'll execute JavaScript in the browser tab..." // Missing error handling awareness
```

### Documentation and Reporting
When documenting MCP server usage:

1. **Always mention** the consolidated v2.0 architecture
2. **Reference** specific security and error handling improvements
3. **Explain** Chrome debugging enhancements and WebSocket management
4. **Note** resource cleanup and logging capabilities
5. **Provide** recovery suggestions for common error types

## Continuous Improvement Integration

### Learning from MCP Operations
```typescript
interface MCPOperationLearning {
  operation: string;
  input: any;
  output: any;
  success: boolean;
  errorType?: string;
  performance: {
    duration: number;
    resourceUsage: string;
  };
  lessons: string[];
  improvements: string[];
}

// Analyze patterns in MCP operations for continuous improvement
function analyzeOperationPatterns(operations: MCPOperationLearning[]): AnalysisResult {
  return {
    commonErrors: extractCommonErrors(operations),
    performanceBottlenecks: identifyBottlenecks(operations),
    successPatterns: identifySuccessPatterns(operations),
    recommendations: generateImprovements(operations)
  };
}
```

This ensures that every interaction with the MCP server leverages its full v2.0 capabilities while maintaining awareness of security, error handling, and resource management improvements.

```


### File: .cursor/rules/chrome-debug-integration.mdc
### Description: Cursor rule: chrome-debug-integration
### Lines:      813
### Size:  24K

```markdown
---
description: "Chrome Debug Protocol integration for automated debugging workflows"
globs: ["**/*.ts", "**/*.tsx", "background.ts", "contents/**/*"]
alwaysApply: false
---
# Chrome Debug Protocol Integration Standards

## Automated Debugging Workflows
Leverage Chrome Debug Protocol for comprehensive debugging without manual intervention:

```typescript
// Debug session management patterns
interface DebugSession {
  tabId: string;
  sessionActive: boolean;
  breakpoints: DebugBreakpoint[];
  consoleMonitoring: boolean;
}

// Automated debugging workflow
const automatedDebugFlow = async (issue: string) => {
  // 1. Launch debug-enabled Chrome
  await launchChromeDebug();
  
  // 2. Connect to debug session
  const session = await connectToChrome();
  
  // 3. Set contextual breakpoints
  await setIntelligentBreakpoints(issue);
  
  // 4. Monitor console for errors
  await startConsoleMonitoring();
  
  // 5. Execute user scenario
  await executeTestScenario(issue);
  
  // 6. Analyze captured data
  return await analyzeDebugData();
};
```

## Intelligent Breakpoint Management
```typescript
// Context-aware breakpoint setting
const setContextualBreakpoints = async (bugContext: string) => {
  const relevantFiles = await identifyRelevantFiles(bugContext);
  
  for (const file of relevantFiles) {
    // Set breakpoints at critical points
    await setBreakpoint(file.path, file.criticalLines);
    
    // Set conditional breakpoints for specific scenarios
    await setConditionalBreakpoint(file.path, line, condition);
  }
};

// Automatic breakpoint strategies
enum BreakpointStrategy {
  ERROR_BOUNDARIES = "error_boundaries",
  STATE_CHANGES = "state_changes", 
  API_CALLS = "api_calls",
  USER_INTERACTIONS = "user_interactions",
  CHROME_API_USAGE = "chrome_api_usage"
}
```

## Console Monitoring and Analysis
```typescript
// Automated console analysis
interface ConsoleAnalysis {
  errorPatterns: string[];
  warningTrends: string[];
  performanceIssues: string[];
  extensionSpecificIssues: string[];
}

const analyzeConsoleOutput = (logs: ConsoleLog[]): ConsoleAnalysis => {
  return {
    errorPatterns: extractErrorPatterns(logs),
    warningTrends: identifyWarningTrends(logs),
    performanceIssues: detectPerformanceIssues(logs),
    extensionSpecificIssues: findExtensionIssues(logs)
  };
};

// Real-time console monitoring
const monitorConsoleForIssues = async () => {
  const session = await getActiveDebugSession();
  
  session.onConsoleLog((log) => {
    if (log.level === 'error') {
      analyzeError(log);
      suggestFix(log);
    }
  });
};
```

## Extension-Specific Debug Patterns
```typescript
// Chrome extension debugging workflows
const debugExtensionFlow = async (component: ExtensionComponent) => {
  switch (component) {
    case 'popup':
      return await debugPopupComponent();
    case 'background':
      return await debugBackgroundScript();
    case 'content':
      return await debugContentScript();
    case 'options':
      return await debugOptionsPage();
  }
};

// Background script debugging
const debugBackgroundScript = async () => {
  // Monitor service worker lifecycle
  await monitorServiceWorkerEvents();
  
  // Track message passing
  await monitorMessagePassing();
  
  // Check extension storage
  await inspectExtensionStorage();
  
  // Verify permissions usage
  await validatePermissions();
};

// Content script debugging
const debugContentScript = async () => {
  // Monitor injection timing
  await trackInjectionTiming();
  
  // Check DOM access issues
  await validateDOMAccess();
  
  // Monitor cross-origin restrictions
  await checkCORSIssues();
  
  // Verify communication with background
  await testMessagePassing();
};
```

## Performance Debugging Automation
```typescript
// Automated performance analysis
interface PerformanceMetrics {
  memoryUsage: MemoryProfile;
  executionTime: TimingProfile;
  networkActivity: NetworkProfile;
  domManipulation: DOMProfile;
}

const analyzeExtensionPerformance = async (): Promise<PerformanceMetrics> => {
  // Start performance monitoring
  await startPerformanceRecording();
  
  // Execute typical user flows
  await simulateUserInteractions();
  
  // Stop recording and analyze
  const data = await stopPerformanceRecording();
  
  return analyzePerformanceData(data);
};

// Memory leak detection
const detectMemoryLeaks = async () => {
  const baseline = await takeMemorySnapshot();
  
  // Execute operations multiple times
  for (let i = 0; i < 10; i++) {
    await executeOperationCycle();
    await forceGarbageCollection();
  }
  
  const final = await takeMemorySnapshot();
  return compareMemorySnapshots(baseline, final);
};
```

## Debug Data Analysis and Reporting
```typescript
// Automated issue analysis
interface DebugReport {
  issueType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  affectedComponents: string[];
  rootCause: string;
  suggestedFixes: string[];
  testSteps: string[];
}

const generateDebugReport = (debugData: DebugData): DebugReport => {
  const analysis = analyzeDebugData(debugData);
  
  return {
    issueType: classifyIssue(analysis),
    severity: assessSeverity(analysis),
    affectedComponents: identifyAffectedComponents(analysis),
    rootCause: determineRootCause(analysis),
    suggestedFixes: generateFixSuggestions(analysis),
    testSteps: createTestSteps(analysis)
  };
};

// Integration with development workflow
const integrateWithWorkflow = async (report: DebugReport) => {
  // Create issue in project management
  await createIssue(report);
  
  // Generate test cases
  await generateTestCases(report);
  
  // Update documentation
  await updateTroubleshootingDocs(report);
  
  // Notify team
  await notifyTeam(report);
};
```

## Debug Protocol Best Practices
1. **Session Management**: Always clean up debug sessions
2. **Resource Monitoring**: Track memory and CPU usage during debugging
3. **Contextual Debugging**: Focus on relevant code paths based on issue description
4. **Automated Analysis**: Let AI analyze patterns rather than manual inspection
5. **Integration**: Connect debug findings to development workflow

## Error Recovery and Failsafes
```typescript
// Robust debugging with fallbacks
const robustDebugSession = async (operation: () => Promise<any>) => {
  let session;
  try {
    session = await connectToChrome();
    return await operation();
  } catch (error) {
    // Fallback to alternative debugging methods
    return await fallbackDebugging(error);
  } finally {
    if (session) {
      await cleanupDebugSession(session);
    }
  }
};

// Automatic recovery from debug failures
const handleDebugFailure = async (error: Error) => {
  if (error.message.includes('connection refused')) {
    // Restart Chrome in debug mode
    await restartChromeDebug();
    return true;
  }
  
  if (error.message.includes('timeout')) {
    // Increase timeout and retry
    await adjustTimeoutSettings();
    return true;
  }
  
  return false; // Manual intervention needed
};
```

## AI-Driven Debug Strategies
- Use pattern recognition to identify common issue types
- Automatically correlate user reports with debug data
- Generate hypothesis-driven debug plans
- Continuously learn from debug session outcomes
- Integrate with code review feedback for preventive debugging

## CDP WebSocket Message Handling (Critical Patterns)
```typescript
// CRITICAL: Proper CDP WebSocket message handling
// Issue discovered: Extension events flood the WebSocket connection
// Solution: Filter messages by command ID and handle async responses properly

const properCDPConnection = async (tabId: string) => {
  const ws = await connectToTab(tabId);
  
  // Helper function to wait for specific command responses
  const sendCommandAndWait = async (commandId: number, method: string, params?: any) => {
    const message = { id: commandId, method, params: params || {} };
    await ws.send(JSON.stringify(message));
    
    // CRITICAL: Must wait for specific command ID, not first message
    while (true) {
      const response = await ws.recv();
      const data = JSON.parse(response);
      
      // Return only our command response
      if (data.id === commandId) {
        return data;
      }
      
      // Filter out extension events (very common)
      if (data.method && data.method.includes('Runtime.executionContextCreated')) {
        continue; // Chrome extensions create many contexts
      }
      
      if (data.method && data.method.includes('Runtime.consoleAPICalled')) {
        continue; // Extension console logs
      }
    }
  };
  
  return { sendCommandAndWait, ws };
};

// IMPORTANT: DevTools interference pattern
// ISSUE: Having Chrome DevTools open on the same tab interferes with external CDP
// SOLUTION: Close DevTools before external CDP automation
const ensureCleanCDPEnvironment = async (tabId: string) => {
  // Check if DevTools is open on target tab
  const tabs = await getChromeTabs();
  const devToolsTab = tabs.find(tab => 
    tab.url.includes('devtools://') && tab.url.includes(tabId)
  );
  
  if (devToolsTab) {
    console.warn('⚠️  DevTools open on target tab - may interfere with CDP');
    // Request user to close DevTools
    return false;
  }
  
  return true;
};
```

## Test Automation via CDP (Working Patterns)
```typescript
// Pattern discovered: Running existing test frameworks via CDP
const runTestsViaCDP = async (tabId: string) => {
  const { sendCommandAndWait } = await properCDPConnection(tabId);
  
  // 1. Enable Runtime domain
  await sendCommandAndWait(1, 'Runtime.enable');
  
  // 2. Check for existing test framework
  const testFrameworkCheck = await sendCommandAndWait(2, 'Runtime.evaluate', {
    expression: 'typeof window.testRunner',
    returnByValue: true
  });
  
  if (testFrameworkCheck.result.result.value === 'object') {
    // 3. Execute test suite
    const testResults = await sendCommandAndWait(3, 'Runtime.evaluate', {
      expression: `
        (async () => {
          const results = await window.testRunner.run();
          return {
            total: results.length,
            passed: results.filter(r => r.status === 'PASS').length,
            failed: results.filter(r => r.status === 'FAIL').length
          };
        })()
      `,
      awaitPromise: true,
      returnByValue: true
    });
    
    return testResults.result.result.value;
  }
  
  return null;
};

// Custom test injection pattern
const injectAndRunCustomTests = async (tabId: string, tests: TestDefinition[]) => {
  const { sendCommandAndWait } = await properCDPConnection(tabId);
  
  // Inject test framework if needed
  await sendCommandAndWait(1, 'Runtime.evaluate', {
    expression: `
      if (!window.cdpTestRunner) {
        window.cdpTestRunner = {
          tests: [],
          run: async function() {
            const results = [];
            for (const test of this.tests) {
              try {
                await test.fn();
                results.push({name: test.name, status: 'PASS'});
              } catch(e) {
                results.push({name: test.name, status: 'FAIL', error: e.message});
              }
            }
            return results;
          }
        };
      }
    `
  });
  
  // Add tests dynamically
  for (const test of tests) {
    await sendCommandAndWait(2, 'Runtime.evaluate', {
      expression: `
        window.cdpTestRunner.tests.push({
          name: "${test.name}",
          fn: ${test.function.toString()}
        });
      `
    });
  }
  
  // Execute all tests
  return await sendCommandAndWait(3, 'Runtime.evaluate', {
    expression: 'window.cdpTestRunner.run()',
    awaitPromise: true,
    returnByValue: true
  });
};
```

## Extension Context Management
```typescript
// Handle multiple Chrome extension contexts in single tab
const manageExtensionContexts = async (tabId: string) => {
  const { ws } = await properCDPConnection(tabId);
  
  const contexts = new Map();
  
  // Listen for context creation events
  ws.onMessage((message) => {
    const data = JSON.parse(message);
    
    if (data.method === 'Runtime.executionContextCreated') {
      const context = data.params.context;
      
      if (context.origin.startsWith('chrome-extension://')) {
        contexts.set(context.id, {
          extensionId: context.origin.split('//')[1],
          name: context.name,
          type: context.auxData.type
        });
      }
    }
  });
  
  return contexts;
};

// Target specific execution context
const executeInMainContext = async (tabId: string, code: string) => {
  const { sendCommandAndWait } = await properCDPConnection(tabId);
  
  // Get available contexts
  const contextsResponse = await sendCommandAndWait(1, 'Runtime.evaluate', {
    expression: '1', // Simple expression to get context info
    returnByValue: true
  });
  
  // Execute in main page context (not extension contexts)
  return await sendCommandAndWait(2, 'Runtime.evaluate', {
    expression: code,
    contextId: undefined, // Use default context
    returnByValue: true
  });
};
```

## Debugging Best Practices - Lessons Learned

### 1. Message Flow Management
- **Always** filter WebSocket messages by command ID
- Chrome extensions create lots of execution context noise
- Use proper async/await patterns for command responses

### 2. Environment Preparation  
- Close Chrome DevTools before external CDP automation
- Refresh target page after closing DevTools
- Check for extension interference

### 3. Error Recovery Patterns
```typescript
const robustCDPExecution = async (tabId: string, operation: () => Promise<any>) => {
  try {
    // Ensure clean environment
    const isClean = await ensureCleanCDPEnvironment(tabId);
    if (!isClean) {
      throw new Error('DevTools interference detected');
    }
    
    return await operation();
    
  } catch (error) {
    if (error.message.includes('WebSocket connection')) {
      // Reconnect and retry
      await delay(1000);
      return await operation();
    }
    throw error;
  }
};
```

### 4. Test Integration Strategies
- **Prefer existing test frameworks** over custom injection
- Use `awaitPromise: true` for async test execution  
- Handle both sync and async test patterns
- Monitor console output during test execution

## Critical WebSocket Message Filtering Patterns
**Key Discovery**: Chrome extensions flood CDP WebSocket with contextual messages

```typescript
// WebSocket message filtering for reliable CDP operations
interface CDPMessage {
  id: number;
  method: string;
  result?: any;
  error?: any;
}

// CRITICAL: Filter WebSocket messages by command ID to avoid extension noise
const executeReliableCDP = async (command: any): Promise<any> => {
  const commandId = Date.now() + Math.random(); // Unique ID
  
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error(`CDP command timeout for ID ${commandId}`));
    }, 10000);
    
    // Listen for SPECIFIC command response
    const messageHandler = (message: CDPMessage) => {
      if (message.id === commandId) {
        clearTimeout(timeout);
        ws.removeEventListener('message', messageHandler);
        
        if (message.error) {
          reject(new Error(message.error.message));
        } else {
          resolve(message.result);
        }
      }
      // IGNORE all other messages (extension noise)
    };
    
    ws.addEventListener('message', messageHandler);
    ws.send(JSON.stringify({ id: commandId, ...command }));
  });
};

// Extension context noise patterns to ignore
const EXTENSION_NOISE_PATTERNS = [
  'Runtime.executionContextCreated',
  'Runtime.executionContextDestroyed', 
  'Page.frameNavigated',
  'Network.requestWillBeSent',
  // Extension-specific events that flood the WebSocket
];
```

## DevTools Interference Prevention
**Critical Issue**: DevTools open on same tab blocks external CDP operations

```typescript
// DevTools conflict detection and resolution
const ensureDevToolsClosed = async (tabId: string): Promise<boolean> => {
  try {
    // Check if DevTools is attached to tab
    const debuggerInfo = await chrome.debugger.getTargets();
    const attachedTab = debuggerInfo.find(target => 
      target.tabId === tabId && target.attached
    );
    
    if (attachedTab) {
      console.warn(`⚠️ DevTools attached to tab ${tabId}, CDP operations may fail`);
      return false;
    }
    return true;
  } catch (error) {
    console.error('Failed to check DevTools status:', error);
    return false;
  }
};

// Auto-close DevTools before CDP operations
const prepareTabForCDP = async (tabId: string): Promise<void> => {
  // Send message to close DevTools if open
  try {
    await chrome.tabs.sendMessage(tabId, { 
      action: 'close_devtools',
      reason: 'CDP_AUTOMATION' 
    });
    
    // Wait for DevTools to close
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const isReady = await ensureDevToolsClosed(tabId);
    if (!isReady) {
      throw new Error(`Tab ${tabId} still has DevTools attached`);
    }
  } catch (error) {
    console.warn('Could not auto-close DevTools:', error.message);
  }
};
```

## Continuous Testing Automation Patterns
**Integration**: File watching triggers automated CDP test execution

```typescript
// File watcher integrated with CDP testing
interface TestTrigger {
  filePattern: string[];
  testCommand: string;
  cooldownMs: number;
}

const FILE_WATCH_TRIGGERS: TestTrigger[] = [
  {
    filePattern: ['*.ts', '*.tsx', '*.js', '*.jsx'],
    testCommand: 'await window.testRunner.run()',
    cooldownMs: 1000
  },
  {
    filePattern: ['*.html', '*.css'],
    testCommand: 'await window.validateUI()',
    cooldownMs: 2000
  },
  {
    filePattern: ['*.py'],
    testCommand: 'await window.testBackendIntegration()',
    cooldownMs: 3000
  }
];

// Continuous testing workflow
const startContinuousTesting = async () => {
  const watcher = new FileWatcher(FILE_WATCH_TRIGGERS);
  
  watcher.onChange(async (trigger, changedFile) => {
    console.log(`🔄 File changed: ${changedFile}, running tests...`);
    
    try {
      // Ensure clean CDP environment
      await prepareTabForCDP(testTabId);
      
      // Execute tests via CDP
      const result = await executeReliableCDP({
        method: 'Runtime.evaluate',
        params: {
          expression: trigger.testCommand,
          awaitPromise: true,
          returnByValue: true
        }
      });
      
      // Send results to SocketIO for real-time feedback
      await notifyTestResults(result, changedFile);
      
    } catch (error) {
      console.error(`❌ Test execution failed:`, error);
      await notifyTestError(error, changedFile);
    }
  });
};

// Test result notification system
const notifyTestResults = async (result: any, trigger: string) => {
  const payload = {
    timestamp: Date.now(),
    trigger,
    status: result.value ? 'success' : 'failure',
    results: result.value,
    source: 'continuous_testing'
  };
  
  // Send to SocketIO for real-time UI updates
  await fetch('http://localhost:3001/api/test-results', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
};
```

## Service Coordination Patterns
**Architecture**: Coordinated startup/shutdown of multiple development services

```typescript
// Multi-service orchestration for development environment
interface ServiceConfig {
  name: string;
  command: string;
  port?: number;
  healthCheck: () => Promise<boolean>;
  dependencies: string[];
  logFile: string;
}

const DEVELOPMENT_SERVICES: ServiceConfig[] = [
  {
    name: 'MCP_SERVER',
    command: 'python3 mcp_server.py',
    port: 8000,
    healthCheck: () => fetch('http://localhost:8000/health'),
    dependencies: [],
    logFile: 'logs/mcp_server.log'
  },
  {
    name: 'SOCKETIO_SERVER', 
    command: 'node socketio_server.js',
    port: 3001,
    healthCheck: () => fetch('http://localhost:3001'),
    dependencies: [],
    logFile: 'logs/socketio_server.log'
  },
  {
    name: 'PLASMO_DEV',
    command: 'pnpm dev',
    healthCheck: () => checkPlasmoStatus(),
    dependencies: [],
    logFile: 'logs/plasmo_dev.log'
  },
  {
    name: 'CONTINUOUS_TESTING',
    command: 'python3 continuous_test_runner.py',
    healthCheck: () => checkTestRunnerStatus(),
    dependencies: ['MCP_SERVER', 'SOCKETIO_SERVER'],
    logFile: 'logs/continuous_testing.log'
  }
];

// Coordinated service startup with dependency resolution
const startDevelopmentEnvironment = async (): Promise<boolean> => {
  const startedServices = new Set<string>();
  
  // Start services in dependency order
  while (startedServices.size < DEVELOPMENT_SERVICES.length) {
    for (const service of DEVELOPMENT_SERVICES) {
      if (startedServices.has(service.name)) continue;
      
      // Check if dependencies are met
      const dependenciesMet = service.dependencies.every(dep => 
        startedServices.has(dep)
      );
      
      if (!dependenciesMet) continue;
      
      // Start service
      console.log(`🚀 Starting ${service.name}...`);
      await startService(service);
      
      // Wait for health check
      await waitForHealthy(service);
      startedServices.add(service.name);
      
      console.log(`✅ ${service.name} ready`);
    }
  }
  
  return true;
};
```

## Error Recovery and Resilience Patterns
**Robustness**: Handle CDP connection failures and service interruptions

```typescript
// Resilient CDP operations with automatic recovery
const resilientCDPOperation = async (operation: () => Promise<any>, maxRetries = 3): Promise<any> => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Verify connection health before operation
      await ensureCDPConnection();
      
      // Execute operation
      const result = await operation();
      return result;
      
    } catch (error) {
      console.warn(`❌ CDP operation failed (attempt ${attempt}/${maxRetries}):`, error.message);
      
      if (attempt === maxRetries) {
        throw new Error(`CDP operation failed after ${maxRetries} attempts: ${error.message}`);
      }
      
      // Recovery strategies based on error type
      if (error.message.includes('WebSocket')) {
        await reconnectWebSocket();
      } else if (error.message.includes('tab')) {
        await refreshTabConnection();
      } else if (error.message.includes('Runtime')) {
        await enableRuntimeDomain();
      }
      
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }
};

// Connection health monitoring
const monitorCDPHealth = async (): Promise<void> => {
  setInterval(async () => {
    try {
      await executeReliableCDP({
        method: 'Runtime.evaluate',
        params: { expression: '1+1', returnByValue: true }
      });
    } catch (error) {
      console.warn('CDP health check failed, attempting recovery...');
      await recoverCDPConnection();
    }
  }, 30000); // Check every 30 seconds
};
```

```


### File: .cursor/rules/core-architecture.mdc
### Description: Cursor rule: core-architecture
### Lines:       47
### Size: 4.0K

```markdown
---
description: "Core architecture patterns for Plasmo Chrome extension development"
globs: ["**/*.ts", "**/*.tsx", "background.ts", "contents/**/*"]
alwaysApply: true
---

# Plasmo Chrome Extension Architecture Standards

## Project Structure Requirements
- Follow Plasmo framework conventions for file organization
- Use TypeScript for all source files
- Maintain clear separation between popup, background, content scripts, and options pages
- Keep MCP server components isolated in dedicated files

## Chrome Extension Patterns
- Use Manifest V3 standards and APIs
- Implement proper message passing between contexts (popup ↔ background ↔ content)
- Handle async Chrome API calls with proper error handling
- Use Chrome storage APIs for persistence, never localStorage in extension contexts

## React Integration
- Use functional components with hooks
- Implement proper state management for popup and options pages
- Follow React 18 patterns with concurrent features
- Use TypeScript interfaces for all props and state

## File Naming Conventions
```
popup.tsx          # Main popup component
options.tsx        # Extension options page
background.ts      # Service worker background script
contents/          # Content scripts directory
  main.ts          # Primary content script
assets/           # Static assets (icons, images)
```

## Import Standards
- Use relative imports for local modules
- Import types with `import type` syntax
- Group imports: React/external libraries first, then local imports
- Use destructuring for named imports

## Error Handling
- Wrap Chrome API calls in try-catch blocks
- Implement fallback behavior for missing permissions
- Log errors appropriately for debugging
- Use TypeScript strict mode for compile-time error prevention

```


### File: .cursor/rules/mcp-server-standards.mdc
### Description: Cursor rule: mcp-server-standards
### Lines:      329
### Size:  12K

```markdown
---
description: "MCP server development and integration standards"
globs: ["**/*mcp*.py", "**/*mcp*.ts", "**/*mcp*.js", "**/mcp_server.py"]
alwaysApply: false
---
# MCP Server Development Standards v2.0

## Server Consolidation and Architecture

### ⚠️ CRITICAL: Use Consolidated Server
**IMPORTANT**: The project now has a **single consolidated MCP server** that combines all improvements:

- **File to use**: `mcp_server.py` (v2.0.0)
- **Deprecated files**: `mcp_server.py`, `mcp_server_fixed.py`, `mcp_server_backup.py`, `mcp_server_v1.1.1_unicode_fix.py`
- **Benefits**: Eliminates redundancy, comprehensive error handling, enhanced security

### Version 2.0 Improvements
✅ **Unified codebase** - No more duplicate functions across multiple files  
✅ **Enhanced error handling** - Comprehensive exception management with logging  
✅ **Security validation** - Path traversal protection and input sanitization  
✅ **Resource management** - Proper WebSocket cleanup and connection tracking  
✅ **Unicode safety** - Robust handling of emoji and special characters  
✅ **Thread safety** - Protected shared resources with proper locking  
✅ **Logging integration** - Structured logging for debugging and monitoring  

## Development Workflow - CRITICAL CONSTRAINTS

### ⚠️ Server Code Changes Require Restart
**IMPORTANT**: After modifying MCP server code, the server must be restarted and reconnected before testing changes:

1. **Stop current server** (Ctrl+C or kill process)
2. **Use consolidated server**: `python3 mcp_server.py`
3. **Reconnect Cursor** (restart Cursor or wait for automatic reconnection)
4. **Test tools** only after successful restart+reconnection

### Development Testing Workflow
```bash
# 1. Use the consolidated server
python3 mcp_server.py --port 8000

# 2. Verify server is running
curl -s "http://127.0.0.1:8000" | head -5

# 3. Test tools ONLY after restart+reconnection
```

### Common Development Mistakes to Avoid
❌ **Don't**: Use deprecated server files (mcp_server.py, mcp_server_fixed.py, etc.)  
✅ **Do**: Always use `mcp_server.py`  

❌ **Don't**: Try to test tools immediately after editing server code  
✅ **Do**: Always restart server and wait for reconnection  

❌ **Don't**: Ignore resource cleanup warnings in logs  
✅ **Do**: Monitor logs for connection and resource management issues  

## Error Handling Standards v2.0

### Comprehensive Error Response Format
```python
def handle_error(operation: str, error: Exception, context: Dict = None) -> Dict[str, Any]:
    """Enhanced error response format for MCP tools."""
    error_response = {
        "success": False,
        "operation": operation,
        "error": str(error),
        "error_type": type(error).__name__,
        "timestamp": datetime.now().isoformat()
    }
    
    if context:
        error_response["context"] = make_json_safe(context)
    
    # Log error for debugging
    logger.error(f"Error in {operation}: {error}", exc_info=True)
    
    return error_response

# Enhanced decorator for safe operations
def safe_operation(operation_name: str):
    """Decorator for comprehensive error handling."""
    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except FileNotFoundError as e:
                return handle_error(operation_name, e, {"file_operation": True})
            except PermissionError as e:
                return handle_error(operation_name, e, {"permission_issue": True})
            except UnicodeDecodeError as e:
                return handle_error(operation_name, e, {"encoding_issue": True})
            except asyncio.TimeoutError as e:
                return handle_error(operation_name, e, {"timeout_issue": True})
            except Exception as e:
                return handle_error(operation_name, e, {"unexpected_error": True})
        return wrapper
    return decorator
```

## Security Best Practices v2.0

### Enhanced Security Patterns
```python
def validate_file_path(file_path: str, base_dir: str = None) -> bool:
    """Enhanced path validation with security checks."""
    try:
        requested = Path(file_path).resolve()
        base = Path(base_dir or Path.cwd()).resolve()
        
        # Check if path is within allowed directory
        if not str(requested).startswith(str(base)):
            logger.warning(f"Path traversal attempt: {file_path}")
            return False
        
        # Additional security checks
        if any(part.startswith('.') for part in requested.parts[len(base.parts):]):
            logger.warning(f"Hidden directory access attempt: {file_path}")
            return False
            
        return True
    except Exception as e:
        logger.error(f"Path validation error: {e}")
        return False

@mcp.tool()
@safe_operation("secure_file_read")
def secure_file_read(file_path: str) -> Union[str, Dict[str, Any]]:
    """Read file with comprehensive security validation."""
    if not validate_file_path(file_path):
        return {"success": False, "error": "Access denied: invalid file path"}
    
    # Additional size check
    file_path = Path(file_path)
    if file_path.stat().st_size > 50 * 1024 * 1024:  # 50MB limit
        return {"success": False, "error": "File too large for reading"}
    
    with open(file_path, 'r', encoding='utf-8') as f:
        return f.read()
```

## Chrome Debug Protocol Integration v2.0

### Enhanced Chrome Debugging Patterns
```python
# Resource management for WebSocket connections
@asynccontextmanager
async def managed_websocket(ws_url: str):
    """Context manager for safe WebSocket connections."""
    ws = None
    try:
        ws = await websockets.connect(ws_url)
        active_connections.add(ws)
        logger.info(f"WebSocket connection established: {ws_url}")
        yield ws
    except Exception as e:
        logger.error(f"WebSocket connection error: {e}")
        raise
    finally:
        if ws:
            active_connections.discard(ws)
            await ws.close()
            logger.info(f"WebSocket connection closed: {ws_url}")

# Robust command execution
async def execute_chrome_command(ws_url: str, command: str, params: Dict = None) -> Dict[str, Any]:
    """Execute Chrome Debug Protocol command with full error handling."""
    request_id = str(uuid.uuid4())[:8]
    
    try:
        async with managed_websocket(ws_url) as websocket:
            # Send command with timeout
            message = {
                "id": request_id,
                "method": command,
                "params": params or {}
            }
            
            await asyncio.wait_for(
                websocket.send(json.dumps(message)),
                timeout=5.0
            )
            
            # Wait for response with proper filtering
            start_time = time.time()
            while time.time() - start_time < 10:
                try:
                    response = await asyncio.wait_for(websocket.recv(), timeout=1.0)
                    data = json.loads(response)
                    
                    if data.get("id") == request_id:
                        return {
                            "success": True,
                            "result": make_json_safe(data.get("result", {})),
                            "error": data.get("error"),
                            "timestamp": datetime.now().isoformat()
                        }
                        
                except asyncio.TimeoutError:
                    continue
            
            return {"success": False, "error": "Command timeout"}
            
    except Exception as e:
        logger.error(f"Chrome command error: {e}")
        return {"success": False, "error": str(e)}
```

## Tool Categories and Organization v2.0

### Enhanced Tool Structure
```python
# Core File Operations (with security)
- `read_file`: Secure file reading with path validation
- `write_file`: Atomic file writing with backup creation
- `list_files`: Directory listing with security filtering
- `search_in_files`: Content search with regex support and size limits

# Development Tools (enhanced)
- `analyze_code`: Comprehensive code metrics and complexity analysis
- `get_project_structure`: Intelligent project tree with ignore patterns
- `run_git_command`: Secure git operations with command filtering

# Chrome Extension Debugging (v2.0)
- `connect_to_chrome`: Enhanced connection management with validation
- `launch_chrome_debug`: Multi-platform Chrome launching with fallbacks
- `execute_javascript_fixed`: Robust JS execution with proper async handling
- `get_chrome_tabs`: Intelligent tab filtering with extension detection
- `start_console_monitoring_fixed`: Real-time console monitoring
- `get_console_logs`: Enhanced log retrieval with filtering
- `clear_console_logs`: Safe log cleanup
- `set_breakpoint_fixed`: Intelligent breakpoint management

# System Operations (enhanced)
- `get_system_info`: Comprehensive system analysis with privacy controls
- `server_info`: Detailed server status and capabilities
- `create_sqlite_db`: Secure database creation with validation
- `query_sqlite_db`: Safe query execution with injection protection
```

## Performance and Monitoring v2.0

### Logging and Monitoring Standards
```python
# Structured logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mcp_server.log'),
        logging.StreamHandler()
    ]
)

# Performance monitoring
@mcp.tool()
def get_server_metrics() -> Dict[str, Any]:
    """Get comprehensive server performance metrics."""
    return {
        "active_connections": len(active_connections),
        "background_tasks": len(background_tasks),
        "chrome_instances": len(chrome_instances),
        "console_listeners": len(console_log_listeners),
        "total_console_logs": len(console_logs),
        "memory_usage": get_memory_usage(),
        "uptime": get_server_uptime(),
        "timestamp": datetime.now().isoformat()
    }
```

## Migration Guide

### From Legacy Servers to Consolidated v2.0
1. **Stop all existing MCP servers**
2. **Update Cursor configuration** to use `mcp_server.py`
3. **Test all tools** to ensure functionality
4. **Monitor logs** for any migration issues
5. **Remove legacy server files** after successful validation

### Configuration Updates
```json
{
  "mcpServers": {
    "plasmo-dev-assistant-v2": {
      "transport": {
        "type": "http",
        "url": "http://127.0.0.1:8000"
      },
      "description": "Consolidated MCP server v2.0 with enhanced Chrome debugging",
      "capabilities": [
        "secure_file_operations",
        "enhanced_code_analysis", 
        "safe_git_integration",
        "robust_chrome_debugging",
        "real_time_console_monitoring",
        "intelligent_error_handling"
      ]
    }
  }
}
```

## Knowledge Injection Requirements

### MCP Server Context Awareness
When using the MCP server in any conversation, the AI assistant must be aware of:

1. **Current server version**: v2.0.0 Consolidated Edition
2. **Available tools and capabilities**: Full tool list with enhanced features
3. **Error handling patterns**: Comprehensive error responses with logging
4. **Security constraints**: Path validation and input sanitization
5. **Chrome debugging capabilities**: Real-time monitoring and robust execution
6. **Resource management**: Connection tracking and cleanup procedures

### Context Injection Pattern
```typescript
// Include in every MCP-related conversation:
interface MCPServerContext {
  version: "2.0.0";
  serverFile: "mcp_server.py";
  capabilities: string[];
  securityFeatures: string[];
  chromeDebugging: boolean;
  resourceManagement: boolean;
  errorHandling: "comprehensive";
  unicode_support: boolean;
}
```

This ensures that any conversation using the MCP server has full context about its capabilities, limitations, and proper usage patterns.

```


### File: .cursor/rules/planning-methodology.mdc
### Description: Cursor rule: planning-methodology
### Lines:      111
### Size: 4.0K

```markdown
---
description: "Project planning and agile development practices"
globs: ["**/docs/**", "**/*.md", "**/planning/**", "**/stories/**"]
alwaysApply: false
---

# Project Planning & Development Methodology

## User Story Standards
Follow INVEST criteria for all user stories:
- **Independent**: Stories can be developed separately
- **Negotiable**: Details can be discussed and refined
- **Valuable**: Provides clear user value
- **Estimable**: Can be sized appropriately
- **Small**: Completed within one sprint
- **Testable**: Clear acceptance criteria

## Story Format
```markdown
## [Story ID] - [Brief Title]

**As a** [persona]  
**I want** [goal]  
**So that** [benefit]

### Acceptance Criteria
- [ ] Given [context], when [action], then [outcome]
- [ ] Given [context], when [action], then [outcome]
- [ ] Given [context], when [action], then [outcome]

### Technical Notes
- API endpoints required
- Database changes needed
- Security considerations
- Performance requirements

### Definition of Done
- [ ] Code implemented and reviewed
- [ ] Unit tests written and passing
- [ ] Integration tests passing
- [ ] Documentation updated
- [ ] Accessibility verified
- [ ] Security review completed
```

## Sprint Planning Process
1. **Sprint Goal Definition**: Clear, measurable objective
2. **Capacity Planning**: Account for team availability
3. **Story Prioritization**: Value-driven backlog ordering
4. **Task Breakdown**: Stories decomposed to 4-8 hour tasks
5. **Risk Assessment**: Identify and mitigate blockers

## Chrome Extension Specific Planning
- Consider Chrome Web Store review cycles (7-14 days)
- Plan for Manifest V3 compliance updates
- Account for cross-browser compatibility testing
- Include security review for permissions

## Development Workflow
```
1. Feature Branch Creation
   ├── git checkout -b feature/STORY-ID-brief-description
   
2. Development Process
   ├── Implement feature following TDD
   ├── Write/update documentation
   ├── Add/update tests
   └── Manual testing in Chrome

3. Code Review
   ├── Create pull request with story context
   ├── Include screenshots/demo for UI changes
   ├── Verify all checks pass
   └── Address review feedback

4. Quality Assurance
   ├── Test in multiple Chrome versions
   ├── Verify extension permissions
   ├── Test installation/update flow
   └── Cross-platform validation

5. Release Planning
   ├── Version bump according to semver
   ├── Update changelog
   ├── Package for Chrome Web Store
   └── Plan rollback strategy
```

## Technical Debt Management
- Maintain technical debt backlog
- Allocate 20% of sprint capacity to debt reduction
- Regular architecture reviews
- Dependency update cycles

## Risk Management
- **High**: Chrome API deprecations, store policy changes
- **Medium**: Third-party dependency issues, performance degradation
- **Low**: Minor UI/UX improvements, non-critical features

## Stakeholder Communication
- Weekly progress updates with screenshots
- Monthly demo sessions
- Quarterly architecture reviews
- Regular user feedback collection

## Metrics and KPIs
- Sprint velocity and burndown
- Code coverage trends
- User adoption rates
- Store review ratings
- Performance metrics (load times, memory usage)

```


### File: .cursor/rules/retrospectives-improvement.mdc
### Description: Cursor rule: retrospectives-improvement
### Lines:      200
### Size: 8.0K

```markdown
---
description: "Sprint retrospectives and continuous improvement processes"
globs: ["**/retrospectives/**", "**/post-mortems/**", "**/improvement/**"]
alwaysApply: false
---

# Retrospectives & Continuous Improvement

## Sprint Retrospective Format
Conduct retrospectives using the "Start, Stop, Continue" framework with additional elements:

```markdown
# Sprint [Number] Retrospective
**Date**: [Date]  
**Participants**: [Team Members]  
**Sprint Goal**: [Original Goal]  
**Goal Achievement**: [Met/Partially Met/Not Met]

## Metrics Review
- **Velocity**: [Points completed vs planned]
- **Quality**: [Bugs found, test coverage, code review feedback]
- **Chrome Extension**: [Store ratings, user feedback, performance metrics]
- **Technical Debt**: [Items addressed vs added]

## What Went Well (Continue)
- [Specific positive outcomes]
- [Effective practices to maintain]
- [Successful collaborations]

## What Didn't Go Well (Stop)
- [Issues that hindered progress]
- [Ineffective practices to eliminate]
- [Communication breakdowns]

## What We Should Try (Start)
- [New practices to experiment with]
- [Tools or processes to adopt]
- [Skills to develop]

## Action Items
- [ ] [Specific action] - Owner: [Name] - Due: [Date]
- [ ] [Process improvement] - Owner: [Name] - Due: [Date]
- [ ] [Technical change] - Owner: [Name] - Due: [Date]

## Chrome Extension Specific Insights
- Store review feedback analysis
- User support ticket patterns
- Performance monitoring results
- Security audit findings

## Team Health Assessment
Rate 1-5 (5 = excellent):
- **Collaboration**: [Score] - [Notes]
- **Learning**: [Score] - [Notes]
- **Fun**: [Score] - [Notes]
- **Delivering Value**: [Score] - [Notes]
```

## Retrospective Facilitation Guidelines
1. **Psychological Safety**: Focus on systems, not individuals
2. **Data-Driven**: Use metrics to support observations
3. **Actionable Outcomes**: Every insight should lead to specific actions
4. **Time-boxed**: 90 minutes maximum for 2-week sprints
5. **Rotating Facilitation**: Different team member each sprint

## Post-Mortem Process
For significant issues or outages:

```markdown
# Post-Mortem: [Incident Title]
**Date**: [Incident Date]  
**Duration**: [How long issue persisted]  
**Impact**: [Users affected, functionality lost]  
**Severity**: [Critical/High/Medium/Low]

## Timeline
- **[Time]**: [Event description]
- **[Time]**: [Event description]
- **[Time]**: [Resolution achieved]

## Root Cause Analysis
- **Immediate Cause**: [What directly caused the issue]
- **Contributing Factors**: [What made this possible]
- **Root Cause**: [Underlying system/process issue]

## What Went Well
- [Effective response actions]
- [Good monitoring/alerting]
- [Successful communication]

## What Could Be Improved
- [Response time issues]
- [Missing monitoring]
- [Communication gaps]

## Action Items
- [ ] [Immediate fix] - Owner: [Name] - Due: [Date]
- [ ] [Process improvement] - Owner: [Name] - Due: [Date]
- [ ] [Monitoring enhancement] - Owner: [Name] - Due: [Date]
- [ ] [Documentation update] - Owner: [Name] - Due: [Date]

## Prevention Measures
- [System changes to prevent recurrence]
- [Process improvements]
- [Training or knowledge sharing needed]
```

## Continuous Improvement Framework

### Monthly Technical Health Review
- Code quality metrics analysis
- Performance monitoring review
- Security audit results
- Dependency update status
- Technical debt assessment

### Quarterly Architecture Review
- Design pattern effectiveness
- Technology stack evaluation
- Scalability assessment
- Integration point analysis
- Future technology planning

### Learning and Development Tracking
```markdown
## Team Learning Goals - Q[Quarter] [Year]

### Individual Development Plans
- **[Team Member]**: [Skills to develop] - [Learning resources] - [Timeline]
- **[Team Member]**: [Skills to develop] - [Learning resources] - [Timeline]

### Team-wide Learning Initiatives
- [ ] [Technology workshop] - [Date] - [Facilitator]
- [ ] [Best practices sharing] - [Date] - [Topic]
- [ ] [External conference/training] - [Event] - [Attendees]

### Knowledge Sharing Sessions
- **Brown Bag Lunches**: [Schedule and topics]
- **Code Reviews**: [Focus areas for learning]
- **Pair Programming**: [Rotation schedule]
```

## Metrics for Continuous Improvement

### Development Metrics
- Sprint velocity trends
- Code review feedback patterns
- Bug discovery timing (dev vs production)
- Test coverage evolution
- Build/deployment success rates

### Extension-Specific Metrics
- Chrome Web Store ratings and reviews
- User adoption and retention rates
- Extension performance (load times, memory usage)
- Permission usage analytics
- Update success rates

### Team Health Metrics
- Retrospective action item completion rate
- Team satisfaction surveys
- Knowledge sharing frequency
- Cross-training effectiveness
- Innovation time usage

## Improvement Experiment Framework
```markdown
## Improvement Experiment: [Title]
**Hypothesis**: [What we believe will improve]  
**Success Criteria**: [How we'll measure success]  
**Duration**: [Experiment timeline]  
**Participants**: [Who's involved]

### Implementation Plan
- [Step 1 with timeline]
- [Step 2 with timeline]
- [Step 3 with timeline]

### Measurements
- **Baseline**: [Current state metrics]
- **Target**: [Desired improvement]
- **Measurement Method**: [How we'll track progress]

### Results
- [Actual outcomes vs targets]
- [Unexpected effects]
- [Lessons learned]

### Decision
- [ ] Adopt permanently
- [ ] Modify and continue
- [ ] Discontinue
```

## Communication and Follow-up
- Share retrospective summaries with stakeholders
- Update team charter and working agreements
- Track action item completion in next retrospectives
- Celebrate improvements and learning achievements
- Document successful practices for future teams

```


### File: .cursor/rules/specification-standards.mdc
### Description: Cursor rule: specification-standards
### Lines:      202
### Size: 8.0K

```markdown
---
description: "API documentation and technical specification standards"
globs: ["**/docs/**", "**/*.md", "**/api/**", "**/specs/**"]
alwaysApply: false
---

# API Documentation & Technical Specifications

## API Documentation Structure
Follow OpenAPI/Swagger standards for all APIs including MCP server endpoints:

```yaml
# MCP Server API Specification
openapi: 3.0.3
info:
  title: Plasmo Extension MCP Server
  description: Model Context Protocol server for development tools
  version: 1.0.0
  contact:
    name: Development Team
    email: dev@example.com

servers:
  - url: http://localhost:8000
    description: Local development server

paths:
  /tools:
    get:
      summary: List available MCP tools
      description: Returns all available development tools
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Tool'
```

## Chrome Extension API Documentation
Document all Chrome API integrations:

```typescript
/**
 * Background Script Message Handler
 * 
 * @description Handles messages from popup and content scripts
 * @param request - Message request object
 * @param sender - Message sender information
 * @param sendResponse - Response callback function
 * 
 * @example
 * // From popup to background
 * chrome.runtime.sendMessage({
 *   action: 'getTabInfo'
 * }, (response) => {
 *   console.log('Current tab:', response.title);
 * });
 */
interface MessageRequest {
  action: 'getTabInfo' | 'showNotification' | string;
  data?: unknown;
}

interface MessageResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}
```

## Technical Specification Templates

### Feature Specification
```markdown
# Feature: [Feature Name]

## Overview
Brief description of the feature and its purpose.

## Requirements
- Functional requirements
- Non-functional requirements (performance, security, etc.)
- Browser compatibility requirements

## Architecture
- Component diagrams
- Data flow diagrams
- Integration points

## API Design
- Endpoint specifications
- Message passing protocols
- Data schemas

## Security Considerations
- Permission requirements
- Data handling policies
- User privacy protections

## Testing Strategy
- Unit test requirements
- Integration test scenarios
- Manual testing procedures

## Performance Requirements
- Load time targets
- Memory usage limits
- Network efficiency goals

## Rollout Plan
- Development phases
- Testing milestones
- Release criteria
```

## Code Documentation Standards
Use JSDoc for all public APIs:

```typescript
/**
 * Highlights text on the current page
 * 
 * @param text - The text to highlight
 * @param color - Highlight color (default: yellow)
 * @returns Promise resolving to highlight count
 * 
 * @example
 * ```typescript
 * const count = await highlightText('search term', '#ffff00');
 * console.log(`Highlighted ${count} instances`);
 * ```
 * 
 * @throws {Error} When DOM access is restricted
 * @since 1.0.0
 */
async function highlightText(text: string, color: string = '#ffff00'): Promise<number> {
  // Implementation
}
```

## README Structure
```markdown
# Project Name

Brief description and key features.

## Installation
Step-by-step setup instructions.

## Usage
Common use cases with examples.

## API Reference
Link to detailed API documentation.

## Development
- Setup instructions
- Build process
- Testing guidelines
- Contributing guidelines

## Architecture
High-level system overview.

## Security
Security considerations and best practices.

## Changelog
Link to detailed changelog.

## License
License information.
```

## Living Documentation Principles
- Keep documentation close to code
- Update docs with every feature change
- Include interactive examples where possible
- Maintain versioned documentation
- Use automated documentation generation

## Quality Checklist
- [ ] Clear, jargon-free language
- [ ] Comprehensive examples
- [ ] Up-to-date screenshots
- [ ] Working code samples
- [ ] Error scenarios documented
- [ ] Performance characteristics noted
- [ ] Security implications covered
- [ ] Browser compatibility noted

## Documentation Review Process
1. Technical accuracy review
2. Clarity and completeness check
3. Example validation
4. Link verification
5. Accessibility compliance
6. Multi-audience validation (developers, stakeholders, end-users)

```


### File: .cursor/rules/testing-strategy.mdc
### Description: Cursor rule: testing-strategy
### Lines:      121
### Size: 4.0K

```markdown
---
description: "Testing strategy and implementation for Plasmo Chrome extension"
globs: ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "**/*.spec.tsx", "**/tests/**"]
alwaysApply: false
---

# Testing Standards for Plasmo Extension

## Testing Framework Setup
- Use Jest as the primary testing framework
- Implement React Testing Library for component testing
- Use MSW (Mock Service Worker) for API mocking
- Configure Chrome API mocks for extension testing

## Test Structure and Organization
```typescript
// Component test structure
describe('PopupComponent', () => {
  const mockOnAction = jest.fn();
  
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('should render with correct props', () => {
    render(<PopupComponent title="Test" onAction={mockOnAction} />);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });
  
  it('should handle user interactions', async () => {
    const user = userEvent.setup();
    render(<PopupComponent title="Test" onAction={mockOnAction} />);
    
    await user.click(screen.getByRole('button', { name: /action/i }));
    expect(mockOnAction).toHaveBeenCalledWith(expectedData);
  });
});
```

## Chrome Extension Testing
```typescript
// Mock Chrome APIs
const mockChrome = {
  runtime: {
    sendMessage: jest.fn(),
    onMessage: {
      addListener: jest.fn(),
      removeListener: jest.fn(),
    },
  },
  storage: {
    sync: {
      get: jest.fn(),
      set: jest.fn(),
    },
  },
};

Object.assign(global, { chrome: mockChrome });
```

## Test Categories
1. **Unit Tests**: Individual functions and hooks
2. **Component Tests**: React component behavior
3. **Integration Tests**: Message passing between extension parts
4. **E2E Tests**: Full user workflows using Playwright

## Testing Patterns
- Test user behavior, not implementation details
- Use descriptive test names that explain scenarios
- Follow Given-When-Then structure
- Mock external dependencies appropriately

## Coverage Requirements
- Maintain minimum 80% code coverage
- Focus on critical path testing
- Test error conditions and edge cases
- Include accessibility testing with jest-axe

## Test Data Management
```typescript
// Test fixtures and factories
export const createMockExtensionData = (overrides = {}) => ({
  title: 'Test Extension',
  settings: {
    notifications: true,
    theme: 'light',
  },
  ...overrides,
});
```

## Continuous Testing
- Run tests on every commit (pre-commit hooks)
- Include tests in CI/CD pipeline
- Generate coverage reports
- Test against multiple Chrome versions

## Background Script Testing
```typescript
// Test background script functionality
describe('Background Script', () => {
  it('should handle installation events', () => {
    const installationHandler = chrome.runtime.onInstalled.addListener.mock.calls[0][0];
    
    installationHandler({ reason: 'install' });
    
    expect(chrome.storage.sync.set).toHaveBeenCalledWith({
      settings: expect.objectContaining({
        notifications: true,
      }),
    });
  });
});
```

## Content Script Testing
- Test DOM manipulation functions
- Mock browser APIs appropriately
- Test message handling between contexts
- Verify injection and cleanup behavior

```


### File: .cursor/rules/typescript-react-standards.mdc
### Description: Cursor rule: typescript-react-standards
### Lines:       87
### Size: 4.0K

```markdown
---
description: "TypeScript and React coding standards for Plasmo extension"
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---

# TypeScript & React Coding Standards

## TypeScript Configuration
- Use strict mode with all strictness flags enabled
- Prefer `interface` over `type` for object shapes
- Use proper generic constraints and utility types
- Implement discriminated unions for complex state

## React Patterns
```typescript
// Preferred component structure
interface ComponentProps {
  title: string;
  onAction?: (data: ActionData) => void;
}

export function ComponentName({ title, onAction }: ComponentProps) {
  const [state, setState] = useState<StateType>(initialState);
  
  // Event handlers
  const handleEvent = useCallback((data: ActionData) => {
    // Implementation
    onAction?.(data);
  }, [onAction]);
  
  // Effects
  useEffect(() => {
    // Setup and cleanup
    return () => {
      // Cleanup
    };
  }, [dependencies]);
  
  return (
    <div className="component-container">
      {/* JSX content */}
    </div>
  );
}
```

## Chrome API Integration
```typescript
// Proper Chrome API usage with error handling
const sendMessage = async (action: string, data?: unknown) => {
  try {
    const response = await chrome.runtime.sendMessage({ action, data });
    if (chrome.runtime.lastError) {
      throw new Error(chrome.runtime.lastError.message);
    }
    return response;
  } catch (error) {
    console.error('Message sending failed:', error);
    throw error;
  }
};
```

## State Management
- Use `useState` for local component state
- Use `useReducer` for complex state logic
- Implement custom hooks for shared logic
- Use React Query or SWR for async data fetching

## Code Organization
- One component per file
- Export components as named exports
- Use barrel exports (index.ts) for directories
- Group related functionality in custom hooks

## Performance
- Use `useCallback` and `useMemo` appropriately
- Implement proper dependency arrays
- Avoid inline object/function creation in render
- Use React.memo for expensive components

## CSS Integration
- Use CSS modules or styled-components
- Follow BEM naming convention for class names
- Implement responsive design patterns
- Use CSS custom properties for theming

```



=================================================================================
= CORE EXTENSION FILES
=================================================================================


### File: package.json
### Description: NPM package configuration
### Lines:       36
### Size: 4.0K

```json
{
  "name": "my-plasmo-extension",
  "displayName": "My Plasmo Extension",
  "version": "0.0.1",
  "description": "A basic Chrome extension built with Plasmo",
  "author": "Your Name",
  "scripts": {
    "dev": "plasmo dev",
    "build": "plasmo build",
    "package": "plasmo package"
  },
  "dependencies": {
    "express": "^5.1.0",
    "plasmo": "0.90.5",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.7.2"
  },
  "devDependencies": {
    "@types/chrome": "0.0.246",
    "@types/node": "20.5.9",
    "@types/react": "18.2.21",
    "@types/react-dom": "18.2.7",
    "nodemon": "^3.1.10",
    "prettier": "^3.0.0",
    "typescript": "5.2.2"
  },
  "manifest": {
    "permissions": [
      "activeTab",
      "storage",
      "nativeMessaging"
    ]
  }
}

```


### File: tsconfig.json
### Description: TypeScript configuration
### Lines:       32
### Size: 4.0K

```json
{
  "compilerOptions": {
    "target": "es2020",
    "lib": [
      "dom",
      "dom.iterable",
      "es6"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    ".plasmo/index.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules",
    "build"
  ]
}

```


### File: popup.tsx
### Description: Extension popup interface
### Lines:      128
### Size: 8.0K

```tsx
import { useState, useEffect } from "react"

import "./style.css"

function IndexPopup() {
  const [data, setData] = useState("")
  const [socketStatus, setSocketStatus] = useState<{connected: boolean, serverUrl: string}>({
    connected: false,
    serverUrl: ""
  })
  const [loading, setLoading] = useState(false)

  // Get socket status on component mount
  useEffect(() => {
    chrome.runtime.sendMessage({ action: "get_socket_status" }, (response) => {
      if (response) {
        setSocketStatus(response)
      }
    })
  }, [])

  const handleReconnectMCP = async () => {
    setLoading(true)
    
    try {
      const response = await new Promise((resolve) => {
        chrome.runtime.sendMessage({ action: "reconnect_mcp_manual" }, resolve)
      })
      
      if (response.success) {
        setData("✅ MCP Server reconnected successfully!")
      } else {
        setData(`❌ Failed to reconnect: ${response.error}`)
      }
    } catch (error) {
      setData(`❌ Error: ${error}`)
    } finally {
      setLoading(false)
    }
  }

  const refreshSocketStatus = () => {
    chrome.runtime.sendMessage({ action: "get_socket_status" }, (response) => {
      if (response) {
        setSocketStatus(response)
      }
    })
  }

  return (
    <div className="plasmo-flex plasmo-flex-col plasmo-w-80 plasmo-p-4 plasmo-gap-4">
      <h2 className="plasmo-text-lg plasmo-font-bold">Cursor IDE Controller</h2>
      
      {/* SocketIO Status */}
      <div className="plasmo-border plasmo-rounded plasmo-p-3">
        <h3 className="plasmo-font-semibold plasmo-mb-2">SocketIO Status</h3>
        <div className="plasmo-flex plasmo-items-center plasmo-gap-2 plasmo-mb-2">
          <div 
            className={`plasmo-w-3 plasmo-h-3 plasmo-rounded-full ${
              socketStatus.connected ? 'plasmo-bg-green-500' : 'plasmo-bg-red-500'
            }`}
          />
          <span className="plasmo-text-sm">
            {socketStatus.connected ? 'Connected' : 'Disconnected'}
          </span>
        </div>
        <p className="plasmo-text-xs plasmo-text-gray-600 plasmo-mb-2">
          Server: {socketStatus.serverUrl}
        </p>
        <button 
          onClick={refreshSocketStatus}
          className="plasmo-px-3 plasmo-py-1 plasmo-text-xs plasmo-bg-blue-500 plasmo-text-white plasmo-rounded plasmo-hover:bg-blue-600"
        >
          Refresh Status
        </button>
      </div>

      {/* MCP Reconnection */}
      <div className="plasmo-border plasmo-rounded plasmo-p-3">
        <h3 className="plasmo-font-semibold plasmo-mb-2">MCP Server Control</h3>
        <button
          onClick={handleReconnectMCP}
          disabled={loading}
          className={`plasmo-w-full plasmo-px-4 plasmo-py-2 plasmo-rounded plasmo-font-medium ${
            loading 
              ? 'plasmo-bg-gray-300 plasmo-text-gray-600 plasmo-cursor-not-allowed'
              : 'plasmo-bg-green-500 plasmo-text-white plasmo-hover:bg-green-600'
          }`}
        >
          {loading ? "Reconnecting..." : "🔄 Reconnect MCP Server"}
        </button>
      </div>

      {/* Command Result */}
      {data && (
        <div className="plasmo-border plasmo-rounded plasmo-p-3 plasmo-bg-gray-50">
          <h3 className="plasmo-font-semibold plasmo-mb-2">Result</h3>
          <p className="plasmo-text-sm plasmo-whitespace-pre-wrap">{data}</p>
          <button 
            onClick={() => setData("")}
            className="plasmo-mt-2 plasmo-px-2 plasmo-py-1 plasmo-text-xs plasmo-bg-gray-400 plasmo-text-white plasmo-rounded plasmo-hover:bg-gray-500"
          >
            Clear
          </button>
        </div>
      )}

      {/* Command Examples */}
      <details className="plasmo-border plasmo-rounded plasmo-p-3">
        <summary className="plasmo-font-semibold plasmo-cursor-pointer">
          Available Commands
        </summary>
        <div className="plasmo-mt-2 plasmo-text-xs plasmo-space-y-1">
          <div>• <code>reconnect_mcp</code> - Reconnect MCP server</div>
          <div>• <code>open_file</code> - Open file in Cursor</div>
          <div>• <code>run_command</code> - Execute Cursor command</div>
          <div>• <code>restart_extension</code> - Restart this extension</div>
        </div>
      </details>

      <div className="plasmo-text-xs plasmo-text-gray-500 plasmo-text-center">
        Send commands via SocketIO to control Cursor IDE
      </div>
    </div>
  )
}

export default IndexPopup

```


### File: background.ts
### Description: Extension background script
### Lines:      292
### Size: 8.0K

```typescript
import { io, Socket } from "socket.io-client"

export {}

// Background script for Chrome extension with Cursor IDE control
console.log("Background script loaded")

let socket: Socket | null = null
let nativePort: chrome.runtime.Port | null = null

// Native messaging host name (you'll need to create this)
const NATIVE_HOST_NAME = "com.plasmo.cursor_controller"

// SocketIO Configuration
const SOCKET_SERVER_URL = "ws://localhost:3001" // Your SocketIO server

// Command interface for type safety
interface CursorCommand {
  action: "reconnect_mcp" | "open_file" | "run_command" | "restart_extension"
  payload?: any
  timestamp: number
}

// Initialize SocketIO connection
const initializeSocketConnection = () => {
  if (socket?.connected) return

  socket = io(SOCKET_SERVER_URL, {
    autoConnect: true,
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    maxReconnectionAttempts: 5
  })

  socket.on("connect", () => {
    console.log("✅ Connected to SocketIO server")
    
    // Register this extension instance
    socket?.emit("extension_register", {
      extensionId: chrome.runtime.id,
      timestamp: Date.now()
    })
  })

  socket.on("disconnect", () => {
    console.log("❌ Disconnected from SocketIO server")
  })

  // Listen for Cursor IDE commands
  socket.on("cursor_command", (command: CursorCommand) => {
    console.log("📨 Received Cursor command:", command)
    handleCursorCommand(command)
  })

  socket.on("connect_error", (error) => {
    console.error("❌ SocketIO connection error:", error)
  })
}

// Handle commands received from SocketIO
const handleCursorCommand = async (command: CursorCommand) => {
  try {
    switch (command.action) {
      case "reconnect_mcp":
        await reconnectMcpServer()
        break
      
      case "open_file":
        await openFileInCursor(command.payload?.filePath)
        break
      
      case "run_command":
        await runCursorCommand(command.payload?.command)
        break
      
      case "restart_extension":
        await restartExtension()
        break
      
      default:
        console.warn("Unknown command:", command.action)
    }
    
    // Send success response back to SocketIO server
    socket?.emit("command_result", {
      commandId: command.timestamp,
      status: "success",
      timestamp: Date.now()
    })
    
  } catch (error) {
    console.error("Error executing command:", error)
    
    socket?.emit("command_result", {
      commandId: command.timestamp,
      status: "error",
      error: error.message,
      timestamp: Date.now()
    })
  }
}

// Connect to native messaging host
const connectToNativeHost = () => {
  if (nativePort?.name === NATIVE_HOST_NAME) return nativePort

  try {
    nativePort = chrome.runtime.connectNative(NATIVE_HOST_NAME)
    
    nativePort.onMessage.addListener((message) => {
      console.log("📨 Native host response:", message)
    })
    
    nativePort.onDisconnect.addListener(() => {
      console.log("❌ Native host disconnected")
      nativePort = null
    })
    
    return nativePort
    
  } catch (error) {
    console.error("❌ Failed to connect to native host:", error)
    return null
  }
}

// Cursor IDE command implementations
const reconnectMcpServer = async () => {
  const port = connectToNativeHost()
  if (!port) throw new Error("Native messaging not available")
  
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new Error("MCP reconnection timeout"))
    }, 10000)
    
    const messageListener = (response: any) => {
      if (response.action === "mcp_reconnect_complete") {
        clearTimeout(timeoutId)
        port.onMessage.removeListener(messageListener)
        resolve(response)
      }
    }
    
    port.onMessage.addListener(messageListener)
    
    port.postMessage({
      action: "reconnect_mcp_server",
      timestamp: Date.now()
    })
  })
}

const openFileInCursor = async (filePath: string) => {
  const port = connectToNativeHost()
  if (!port) throw new Error("Native messaging not available")
  
  port.postMessage({
    action: "open_file",
    filePath: filePath,
    timestamp: Date.now()
  })
}

const runCursorCommand = async (command: string) => {
  const port = connectToNativeHost()
  if (!port) throw new Error("Native messaging not available")
  
  port.postMessage({
    action: "run_command",
    command: command,
    timestamp: Date.now()
  })
}

const restartExtension = async () => {
  chrome.runtime.reload()
}

// Listen for extension installation
chrome.runtime.onInstalled.addListener((details) => {
  console.log("Extension installed:", details.reason)
  
  // Initialize SocketIO connection on install
  setTimeout(initializeSocketConnection, 1000)
  
  // Initialize default settings
  if (details.reason === "install") {
    chrome.storage.sync.set({
      settings: {
        notifications: true,
        theme: "light",
        autoUpdate: false,
        socketServerUrl: SOCKET_SERVER_URL,
        cursorControlEnabled: true
      }
    })
  }
})

// Initialize SocketIO connection on startup
initializeSocketConnection()

// Listen for messages from popup or content scripts
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log("Message received:", request)
  
  switch (request.action) {
    case "getTabInfo":
      // Get current tab information
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        if (tabs[0]) {
          sendResponse({
            title: tabs[0].title,
            url: tabs[0].url
          })
        }
      })
      return true // Keep message channel open for async response
      
    case "showNotification":
      // Show a notification
      chrome.notifications.create({
        type: "basic",
        iconUrl: "icon.png",
        title: "My Plasmo Extension",
        message: request.message || "Hello from your extension!"
      })
      sendResponse({ success: true })
      break

    case "reconnect_mcp_manual":
      // Manual MCP reconnection from UI
      reconnectMcpServer()
        .then(() => sendResponse({ success: true }))
        .catch((error) => sendResponse({ success: false, error: error.message }))
      return true
      
    case "get_socket_status":
      sendResponse({
        connected: socket?.connected || false,
        serverUrl: SOCKET_SERVER_URL
      })
      break
      
    default:
      sendResponse({ error: "Unknown action" })
  }
})

// Listen for tab updates
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === "complete" && tab.url) {
    console.log("Tab updated:", tab.url)
    
    // Notify SocketIO server about tab changes if needed
    if (socket?.connected) {
      socket.emit("tab_updated", {
        tabId,
        url: tab.url,
        title: tab.title
      })
    }
  }
})

// Handle browser action (extension icon) clicks
chrome.action.onClicked.addListener((tab) => {
  console.log("Extension icon clicked on tab:", tab.url)
})

// Periodic background tasks
const performPeriodicTask = () => {
  // Maintain SocketIO connection
  if (!socket?.connected) {
    console.log("Reconnecting to SocketIO server...")
    initializeSocketConnection()
  }
  
  // Check settings and perform tasks based on user preferences
  chrome.storage.sync.get(["settings"], (result) => {
    const settings = result.settings || {}
    
    if (settings.autoUpdate) {
      console.log("Auto-update is enabled")
    }
  })
}

// Run periodic task every 30 seconds
setInterval(performPeriodicTask, 30000)

```


### File: options.tsx
### Description: Extension options page
### Lines:      110
### Size: 4.0K

```tsx
import { useState, useEffect } from "react"

import "./options.css"

function OptionsIndex() {
  const [settings, setSettings] = useState({
    notifications: true,
    theme: "light",
    autoUpdate: false
  })

  useEffect(() => {
    // Load settings from Chrome storage
    chrome.storage.sync.get(["settings"], (result) => {
      if (result.settings) {
        setSettings(result.settings)
      }
    })
  }, [])

  const saveSettings = () => {
    chrome.storage.sync.set({ settings }, () => {
      console.log("Settings saved")
      // Show a success message
      const saveBtn = document.getElementById("save-btn")
      if (saveBtn) {
        saveBtn.textContent = "Saved!"
        setTimeout(() => {
          saveBtn.textContent = "Save Settings"
        }, 2000)
      }
    })
  }

  const handleChange = (key: string, value: any) => {
    setSettings(prev => ({
      ...prev,
      [key]: value
    }))
  }

  return (
    <div className="options-container">
      <div className="header">
        <h1>Extension Options</h1>
        <p>Configure your extension settings below</p>
      </div>

      <div className="settings-section">
        <h3>General Settings</h3>
        
        <div className="setting-item">
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={settings.notifications}
              onChange={(e) => handleChange("notifications", e.target.checked)}
            />
            <span className="checkmark"></span>
            Enable notifications
          </label>
          <p className="setting-description">
            Receive notifications when important events occur
          </p>
        </div>

        <div className="setting-item">
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={settings.autoUpdate}
              onChange={(e) => handleChange("autoUpdate", e.target.checked)}
            />
            <span className="checkmark"></span>
            Auto-update content
          </label>
          <p className="setting-description">
            Automatically refresh content in the background
          </p>
        </div>

        <div className="setting-item">
          <label className="select-label">
            Theme:
            <select
              value={settings.theme}
              onChange={(e) => handleChange("theme", e.target.value)}
              className="theme-select"
            >
              <option value="light">Light</option>
              <option value="dark">Dark</option>
              <option value="auto">System</option>
            </select>
          </label>
          <p className="setting-description">
            Choose your preferred color theme
          </p>
        </div>
      </div>

      <div className="actions">
        <button id="save-btn" onClick={saveSettings} className="save-btn">
          Save Settings
        </button>
      </div>
    </div>
  )
}

export default OptionsIndex

```


### File: contents/bolt-automation.ts
### Description: Content script
### Lines:      434
### Size:  16K

```typescript
// Bolt.new automation content script inspired by automata app
import type { PlasmoCSConfig } from "plasmo"

export const config: PlasmoCSConfig = {
    matches: ["https://bolt.new/*"],
    all_frames: false
}

// Utils
function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
}

// Key definitions for proper keyboard simulation
const keyDefinitions: Record<string, { key: string; keyCode: number; code: string }> = {
    ' ': { key: 'Space', keyCode: 32, code: 'Space' },
    'Space': { key: ' ', keyCode: 32, code: 'Space' },
    'a': { key: 'a', keyCode: 65, code: 'KeyA' },
    'b': { key: 'b', keyCode: 66, code: 'KeyB' },
    'c': { key: 'c', keyCode: 67, code: 'KeyC' },
    // Add more as needed...
}

// Native input value setter to bypass React
const nativeInputValueSetter = Object.getOwnPropertyDescriptor(
    window.HTMLInputElement.prototype,
    'value'
)?.set

const nativeTextAreaValueSetter = Object.getOwnPropertyDescriptor(
    window.HTMLTextAreaElement.prototype,
    'value'
)?.set

function simulateEvent(element: HTMLElement, eventType: string, eventData: any) {
    let event: Event

    if (eventType === 'input') {
        event = new InputEvent(eventType, eventData)
    } else if (eventType.startsWith('key')) {
        event = new KeyboardEvent(eventType, eventData)
    } else {
        event = new Event(eventType, eventData)
    }

    element.dispatchEvent(event)
}

function reactJsEvent(element: HTMLInputElement | HTMLTextAreaElement, value: string) {
    if (!(element as any)._valueTracker) return

    const previousValue = element.value

    if (element instanceof HTMLInputElement && nativeInputValueSetter) {
        nativeInputValueSetter.call(element, value)
    } else if (element instanceof HTMLTextAreaElement && nativeTextAreaValueSetter) {
        nativeTextAreaValueSetter.call(element, value)
    }

    if ((element as any)._valueTracker) {
        (element as any)._valueTracker.setValue(previousValue)
    }
}

function formEvent(element: HTMLElement, data: { type: string; value: string; isEditable?: boolean }) {
    if (data.type === 'text-field') {
        const currentKey = /\s/.test(data.value) ? 'Space' : data.value
        const { key, keyCode, code } = keyDefinitions[currentKey] || {
            key: currentKey,
            keyCode: 0,
            code: `Key${currentKey.toUpperCase()}`,
        }

        simulateEvent(element, 'input', {
            inputType: 'insertText',
            data: data.value,
            bubbles: true,
            cancelable: true,
        })

        simulateEvent(element, 'keydown', {
            key,
            code,
            keyCode,
            bubbles: true,
            cancelable: true,
        })

        simulateEvent(element, 'keyup', {
            key,
            code,
            keyCode,
            bubbles: true,
            cancelable: true,
        })
    }

    simulateEvent(element, 'input', {
        inputType: 'insertText',
        data: data.value,
        bubbles: true,
        cancelable: true,
    })

    if (data.type !== 'text-field') {
        element.dispatchEvent(
            new Event('change', { bubbles: true, cancelable: true })
        )
    }
}

async function inputText({
    data,
    element,
    isEditable
}: {
    data: { value: string; delay: number },
    element: HTMLInputElement | HTMLTextAreaElement,
    isEditable: boolean
}) {
    element?.focus()
    element?.click()

    const elementKey = isEditable ? 'textContent' : 'value'

    if (data.delay > 0 && !document.hidden) {
        for (let index = 0; index < data.value.length; index += 1) {
            if (elementKey === 'value') reactJsEvent(element, element.value)

            const currentChar = data.value[index]
            if (elementKey === 'value') {
                element.value += currentChar
            } else {
                (element as any).textContent += currentChar
            }

            formEvent(element, {
                type: 'text-field',
                value: currentChar,
                isEditable,
            })

            await sleep(data.delay)
        }
    } else {
        if (elementKey === 'value') reactJsEvent(element, element.value)

        if (elementKey === 'value') {
            element.value += data.value
        } else {
            (element as any).textContent += data.value
        }

        formEvent(element, {
            isEditable,
            type: 'text-field',
            value: data.value[0] ?? '',
        })
    }

    element.dispatchEvent(
        new Event('change', { bubbles: true, cancelable: true })
    )

    element?.blur()
}

// Real handleFormElement function from automata
async function handleFormElement(element: HTMLElement, data: {
    type: string
    value: string
    delay?: number
    clearValue?: boolean
}) {
    const textFields = ['INPUT', 'TEXTAREA']
    const isEditable = element.hasAttribute('contenteditable') && (element as any).isContentEditable

    console.log(`🔧 handleFormElement: ${data.type} with value: "${data.value}"`)

    if (isEditable) {
        if (data.clearValue) (element as any).innerText = ''

        await inputText({
            data: { value: data.value, delay: data.delay || 50 },
            element: element as HTMLInputElement,
            isEditable
        })
        return true
    }

    if (data.type === 'text-field' && textFields.includes(element.tagName)) {
        const inputElement = element as HTMLInputElement | HTMLTextAreaElement

        if (data.clearValue) {
            inputElement?.select()
            reactJsEvent(inputElement, '')
            inputElement.value = ''
        }

        await inputText({
            data: { value: data.value, delay: data.delay || 50 },
            element: inputElement,
            isEditable: false
        })
        return true
    }

    // Handle other input types...
    element?.focus()

    if (data.type === 'checkbox' || data.type === 'radio') {
        const checkboxElement = element as HTMLInputElement
        checkboxElement.checked = data.value === 'true'
        formEvent(element, { type: data.type, value: data.value })
    }

    element?.blur()
    return true
}

let textarea: HTMLTextAreaElement | null = null

function createBtn(text: string): HTMLButtonElement {
    const btn = document.createElement("button")
    btn.textContent = text
    btn.style.margin = "4px"
    btn.style.padding = "4px 8px"
    btn.style.border = "1px solid #ccc"
    btn.style.background = "#fff"
    btn.style.cursor = "pointer"
    btn.style.fontSize = "12px"
    btn.style.borderRadius = "4px"
    return btn
}

function initUI() {
    // Remove any existing UI
    const existing = document.getElementById("plasmo-bolt-automation")
    if (existing) existing.remove()

    const container = document.createElement("div")
    container.id = "plasmo-bolt-automation"
    container.style.position = "fixed"
    container.style.top = "10px"
    container.style.right = "10px"
    container.style.zIndex = "9999"
    container.style.background = "rgba(255,255,255,0.95)"
    container.style.border = "1px solid #ddd"
    container.style.padding = "8px"
    container.style.fontSize = "14px"
    container.style.borderRadius = "8px"
    container.style.boxShadow = "0 2px 8px rgba(0,0,0,0.1)"
    container.style.fontFamily = "system-ui, sans-serif"

    const title = document.createElement("div")
    title.textContent = "🤖 Bolt Automation"
    title.style.fontWeight = "bold"
    title.style.marginBottom = "8px"
    title.style.fontSize = "12px"
    container.appendChild(title)

    const findBtn = createBtn("Find textarea")
    const injectBtn = createBtn("Inject prompt")
    const submitBtn = createBtn("Submit")
    const autoBtn = createBtn("🚀 Auto Run")

    findBtn.onclick = () => {
        textarea = document.querySelector('textarea[placeholder*="help" i]') as HTMLTextAreaElement
        if (textarea) {
            findBtn.textContent = "✅ Found"
            findBtn.style.background = "#d4edda"
            console.log("✅ Found Bolt.new textarea")
        } else {
            findBtn.textContent = "❌ Not found"
            findBtn.style.background = "#f8d7da"
            console.log("❌ No textarea found")
        }
    }

    injectBtn.onclick = async () => {
        if (!textarea) textarea = document.querySelector('textarea[placeholder*="help" i]') as HTMLTextAreaElement
        if (textarea) {
            console.log("🎯 Injecting prompt using real handleFormElement...")
            const success = await handleFormElement(textarea, {
                type: "text-field",
                value: "Create a simple test webpage with a blue background",
                delay: 80, // Slower typing for better React compatibility
                clearValue: true
            })

            if (success) {
                injectBtn.textContent = "✅ Injected"
                injectBtn.style.background = "#d4edda"
                console.log("✅ Prompt injected successfully")
            } else {
                injectBtn.textContent = "❌ Failed"
                injectBtn.style.background = "#f8d7da"
            }
        } else {
            injectBtn.textContent = "❌ No textarea"
            injectBtn.style.background = "#f8d7da"
        }
    }

    submitBtn.onclick = () => {
        // Look for submit button using multiple strategies
        let btn = textarea?.closest("form")?.querySelector("button:not(.plasmo-btn)") as HTMLButtonElement

        if (!btn) {
            // Try specific Bolt.new submit button selectors
            const selectors = [
                'button.absolute[class*="top-"][class*="right-"][class*="bg-accent-500"]',
                'button[class*="absolute"][class*="top-"][class*="right-"]',
                'button:has(svg):not(.plasmo-btn)'
            ]

            for (const selector of selectors) {
                try {
                    btn = document.querySelector(selector) as HTMLButtonElement
                    if (btn && btn.offsetParent !== null) break
                } catch (e) {
                    continue
                }
            }
        }

        if (btn) {
            console.log("🖱️ Clicking submit button")
            btn.click()
            submitBtn.textContent = "✅ Clicked"
            submitBtn.style.background = "#d4edda"
        } else {
            console.log("❌ No submit button found")
            submitBtn.textContent = "❌ No button"
            submitBtn.style.background = "#f8d7da"
        }
    }

    autoBtn.onclick = async () => {
        console.log("🚀 Starting full automation...")
        autoBtn.textContent = "⏳ Running..."
        autoBtn.disabled = true

        try {
            // Step 1: Find textarea
            textarea = document.querySelector('textarea[placeholder*="help" i]') as HTMLTextAreaElement
            if (!textarea) {
                throw new Error("Textarea not found")
            }
            console.log("✅ Step 1: Found textarea")

            // Step 2: Inject prompt
            await handleFormElement(textarea, {
                type: "text-field",
                value: "Create a simple test webpage with a blue background",
                delay: 80,
                clearValue: true
            })
            console.log("✅ Step 2: Injected prompt")

            // Step 3: Wait for submit button to appear
            await new Promise(resolve => setTimeout(resolve, 1000))

            // Step 4: Click submit
            let btn = textarea?.closest("form")?.querySelector("button:not(.plasmo-btn)") as HTMLButtonElement

            if (!btn) {
                const selectors = [
                    'button.absolute[class*="top-"][class*="right-"][class*="bg-accent-500"]',
                    'button[class*="absolute"][class*="top-"][class*="right-"]',
                    'button:has(svg):not(.plasmo-btn)'
                ]

                for (const selector of selectors) {
                    try {
                        btn = document.querySelector(selector) as HTMLButtonElement
                        if (btn && btn.offsetParent !== null) break
                    } catch (e) {
                        continue
                    }
                }
            }

            if (btn) {
                btn.click()
                console.log("✅ Step 3: Clicked submit")
                autoBtn.textContent = "🎉 Success!"
                autoBtn.style.background = "#d4edda"
            } else {
                throw new Error("Submit button not found")
            }

        } catch (error) {
            console.error("❌ Automation failed:", error)
            autoBtn.textContent = "❌ Failed"
            autoBtn.style.background = "#f8d7da"
        } finally {
            autoBtn.disabled = false
        }
    }

        // Add plasmo-btn class to all our buttons to exclude them from submit button search
        ;[findBtn, injectBtn, submitBtn, autoBtn].forEach((b) => {
            b.classList.add("plasmo-btn")
            container.appendChild(b)
        })

    document.body.appendChild(container)
    console.log("🤖 Plasmo Bolt.new automation UI initialized")
}

// Initialize when page loads
if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initUI)
} else {
    initUI()
}

// Also reinitialize on navigation (for SPA behavior)
const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
            // Check if we're on a bolt.new page and our UI is missing
            if (window.location.hostname === 'bolt.new' && !document.getElementById("plasmo-bolt-automation")) {
                setTimeout(initUI, 1000) // Delay to let page settle
                break
            }
        }
    }
})

observer.observe(document.body, {
    childList: true,
    subtree: true
}) 
```


### File: contents/main.ts
### Description: Content script
### Lines:      369
### Size:  12K

```typescript
import type { PlasmoCSConfig } from "plasmo"

export const config: PlasmoCSConfig = {
  matches: ["<all_urls>"],
  all_frames: true
}

// IMMEDIATE TEST - This should run right away if the script loads
console.log("🚨 CONTENT SCRIPT LOADING - TEST MESSAGE");

// Console log interception setup
const logArray: string[] = [];
const originalConsoleLog = console.log;

console.log = function(...args: any[]) {
  const message = args.map(arg => 
    typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
  ).join(' ');
  
  logArray.push(message);
  const prefixedMessage = `${logArray.length}. ${message}`;
  
  // Call original console.log with prefixed message
  originalConsoleLog.call(console, prefixedMessage);
};

// Global reset function for CDP access
(window as any).resetLogs = function() {
  logArray.length = 0;
  console.log("🔄 Log array reset");
};

// Also add a function to get current log count
(window as any).getLogCount = function() {
  console.log(`📊 Current log count: ${logArray.length}`);
  return logArray.length;
};

// Simple direct assignment to window since we're in MAIN world context
// (window as any).lex = function(...args: any[]) {
//   // Route directly through the extension's overridden console.log
//   console.log(...args);
// };

console.log("🔧 Use Ctrl+Shift+R to reset logs, Ctrl+Shift+C to get count");

console.log("Content script loaded on:", window.location.href)

// Debug: Check which context we're running in
console.log("🔍 CONTEXT DEBUG:", {
  hasChrome: typeof chrome !== 'undefined',
  hasWindow: typeof window !== 'undefined',
  worldContext: window === globalThis ? 'MAIN' : 'ISOLATED',
  chromeRuntime: typeof chrome?.runtime !== 'undefined'
});

// console.log("✅ Extension lex function ready! Use: window.lex('your message')");

// Add keyboard shortcuts for log management (Ctrl+Shift+R for reset, Ctrl+Shift+C for count)
document.addEventListener('keydown', (event) => {
  if (event.ctrlKey && event.shiftKey) {
    if (event.key === 'R') {
      event.preventDefault();
      logArray.length = 0;
      console.log("🔄 Log array reset via keyboard shortcut (Ctrl+Shift+R)");
    } else if (event.key === 'C') {
      event.preventDefault();
      console.log(`📊 Current log count: ${logArray.length} (via Ctrl+Shift+C)`);
    }
  }
});

// Enhanced debugging for textarea behavior
const debugTextareaEvents = () => {
  const textareas = document.querySelectorAll('textarea');
  console.log(`Found ${textareas.length} textarea(s) on page`);
  
  textareas.forEach((textarea, index) => {
    console.log(`Setting up monitoring for textarea ${index}:`, {
      id: textarea.id,
      className: textarea.className,
      placeholder: textarea.placeholder
    });
    
    // Monitor all relevant events
    const events = ['input', 'change', 'keydown', 'keyup', 'keypress', 'focus', 'blur'];
    events.forEach(eventType => {
      textarea.addEventListener(eventType, (event) => {
        console.log(`🎯 ${eventType.toUpperCase()} event:`, {
          type: event.type,
          value: (event.target as HTMLTextAreaElement).value,
          valueLength: (event.target as HTMLTextAreaElement).value.length,
          isTrusted: event.isTrusted,
          inputType: (event as InputEvent).inputType || 'N/A',
          timeStamp: event.timeStamp
        });
      }, true);
    });
    
    // Monitor attribute changes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
          console.log('📝 Textarea value attribute changed:', {
            oldValue: mutation.oldValue,
            newValue: textarea.getAttribute('value'),
            currentValue: textarea.value
          });
        }
      });
    });
    
    observer.observe(textarea, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: ['value']
    });
  });
};

// Function to highlight text on the page
const highlightText = (text: string, color: string = "#ffff00") => {
  const walker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_TEXT,
    null
  )

  const textNodes: Text[] = []
  let node: Node | null

  while ((node = walker.nextNode())) {
    if (node.nodeValue && node.nodeValue.toLowerCase().includes(text.toLowerCase())) {
      textNodes.push(node as Text)
    }
  }

  textNodes.forEach((textNode) => {
    const parent = textNode.parentNode
    if (!parent) return

    const text = textNode.nodeValue || ""
    const regex = new RegExp(`(${text})`, "gi")
    const parts = text.split(regex)

    const fragment = document.createDocumentFragment()
    parts.forEach((part) => {
      if (part.toLowerCase() === text.toLowerCase()) {
        const span = document.createElement("span")
        span.style.backgroundColor = color
        span.style.padding = "2px"
        span.style.borderRadius = "2px"
        span.textContent = part
        fragment.appendChild(span)
      } else {
        fragment.appendChild(document.createTextNode(part))
      }
    })

    parent.replaceChild(fragment, textNode)
  })
}

// Utility functions for testing programmatic input
const testProgrammaticInput = (textarea: HTMLTextAreaElement, text: string) => {
  console.log('🧪 Testing programmatic input methods...');
  
  // Method 1: Direct value assignment
  console.log('Method 1: Direct value assignment');
  textarea.value = text;
  console.log('Value after direct assignment:', textarea.value);
  
  // Method 2: Set attribute
  console.log('Method 2: Set attribute');
  textarea.setAttribute('value', text);
  console.log('Value after setAttribute:', textarea.value);
  
  // Method 3: Simulate typing with events
  console.log('Method 3: Simulate typing events');
  textarea.focus();
  
  // Clear first
  textarea.value = '';
  
  // Type each character
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    
    // Dispatch keydown
    textarea.dispatchEvent(new KeyboardEvent('keydown', {
      key: char,
      bubbles: true,
      cancelable: true
    }));
    
    // Update value
    textarea.value = textarea.value + char;
    
    // Dispatch input event
    textarea.dispatchEvent(new InputEvent('input', {
      data: char,
      inputType: 'insertText',
      bubbles: true,
      cancelable: true
    }));
    
    // Dispatch keyup
    textarea.dispatchEvent(new KeyboardEvent('keyup', {
      key: char,
      bubbles: true,
      cancelable: true
    }));
  }
  
  console.log('Final value after simulated typing:', textarea.value);
};

// Listen for messages from popup or background script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log("Content script received message:", request)

  switch (request.action) {
    case "highlight":
      highlightText(request.text, request.color)
      sendResponse({ success: true, message: "Text highlighted" })
      break

    case "getPageInfo":
      sendResponse({
        title: document.title,
        url: window.location.href,
        wordCount: document.body.innerText.split(/\s+/).length
      })
      break

    case "scrollToTop":
      window.scrollTo({ top: 0, behavior: "smooth" })
      sendResponse({ success: true })
      break

    case "injectCSS":
      const style = document.createElement("style")
      style.textContent = request.css
      document.head.appendChild(style)
      sendResponse({ success: true })
      break
      
    case "debugTextarea":
      debugTextareaEvents()
      sendResponse({ success: true, message: "Textarea debugging enabled" })
      break
      
    case "testInput":
      const textarea = document.querySelector('textarea') as HTMLTextAreaElement;
      if (textarea) {
        testProgrammaticInput(textarea, request.text || "This is a test prompt");
        sendResponse({ success: true, message: "Input test completed" });
      } else {
        sendResponse({ error: "No textarea found" });
      }
      break

    default:
      sendResponse({ error: "Unknown action" })
  }

  return true // Keep message channel open
})

// Add a floating button to demonstrate content script capabilities
const createFloatingButton = () => {
  const button = document.createElement("button") as HTMLButtonElement & { b: (a: any) => void };
  button.textContent = "🚀"
  button.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000;
    width: 50px;
    height: 50px;
    border-radius: 25px;
    border: none;
    background: #1a73e8;
    color: white;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    transition: transform 0.2s;
  `

  button.addEventListener("mouseenter", () => {
    button.style.transform = "scale(1.1)"
  })

  button.addEventListener("mouseleave", () => {
    button.style.transform = "scale(1)"
  })

  button.addEventListener("click", () => {
    // Send message to background script
    chrome.runtime.sendMessage({
      action: "showNotification",
      message: `Hello from ${document.title}!`
    })
  })

  // Add function directly to the button element
  button.b = (a: any) => console.log(a);

  document.body.appendChild(button)

  // Test the button function from the extension
  button.b("🧪 from the extension - button.b() works!");
  console.log("✅ Button function attached! Try: document.querySelector('button[style*=\"position: fixed\"]').b('your message')");
}

// Enhanced DOM monitoring
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
      originalConsoleLog.call(console, "📄 Page content changed")
      
      // Check if any textareas were added
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const element = node as Element;
          const newTextareas = element.querySelectorAll('textarea');
          if (newTextareas.length > 0) {
            console.log(`🆕 ${newTextareas.length} new textarea(s) added to DOM`);
            setTimeout(debugTextareaEvents, 100); // Setup monitoring after a brief delay
          }
        }
      });
    }
    
    // Monitor attribute changes on textareas
    if (mutation.type === "attributes" && 
        mutation.target.nodeType === Node.ELEMENT_NODE &&
        (mutation.target as Element).tagName === 'TEXTAREA') {
      console.log("🔄 Textarea attribute changed:", {
        attribute: mutation.attributeName,
        oldValue: mutation.oldValue,
        newValue: (mutation.target as Element).getAttribute(mutation.attributeName || '')
      });
    }
  })
})

observer.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true,
  attributeOldValue: true
})

// Initialize textarea monitoring when page loads
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', debugTextareaEvents);
} else {
  debugTextareaEvents();
}

// Only add the button on specific sites (to avoid clutter)
if (window.location.hostname.includes("example.com") || 
    window.location.hostname.includes("github.com") ||
    window.location.hostname.includes("chatgpt.com") ||
    window.location.hostname.includes("bolt.new")) {
  createFloatingButton()
}

```


### File: style.css
### Description: Main stylesheet
### Lines:       85
### Size: 4.0K

```css
.plasmo-container {
  width: 320px;
  padding: 20px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #ffffff;
  border-radius: 8px;
}

h2 {
  color: #1a73e8;
  margin: 0 0 16px 0;
  font-size: 20px;
  font-weight: 600;
}

p {
  margin: 0 0 16px 0;
  color: #5f6368;
  line-height: 1.4;
}

.button-group {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}

.primary-btn {
  background: #1a73e8;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: background-color 0.2s;
}

.primary-btn:hover {
  background: #1557b0;
}

.secondary-btn {
  background: #f8f9fa;
  color: #3c4043;
  border: 1px solid #dadce0;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: background-color 0.2s;
}

.secondary-btn:hover {
  background: #f1f3f4;
}

.message {
  background: #e8f0fe;
  border: 1px solid #dadce0;
  padding: 12px;
  border-radius: 4px;
  margin-bottom: 16px;
  color: #1a73e8;
  font-weight: 500;
}

.info {
  background: #f8f9fa;
  padding: 12px;
  border-radius: 4px;
  font-size: 13px;
}

.info ul {
  margin: 8px 0 0 0;
  padding-left: 20px;
}

.info li {
  margin-bottom: 4px;
  color: #5f6368;
}

```


### File: options.css
### Description: Options page stylesheet
### Lines:      127
### Size: 4.0K

```css
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f8f9fa;
}

.options-container {
  max-width: 600px;
  margin: 0 auto;
  padding: 32px 24px;
  background: white;
  min-height: 100vh;
}

.header {
  border-bottom: 1px solid #e0e0e0;
  padding-bottom: 24px;
  margin-bottom: 32px;
}

.header h1 {
  color: #202124;
  font-size: 28px;
  font-weight: 400;
  margin: 0 0 8px 0;
}

.header p {
  color: #5f6368;
  font-size: 16px;
  margin: 0;
}

.settings-section {
  margin-bottom: 32px;
}

.settings-section h3 {
  color: #202124;
  font-size: 18px;
  font-weight: 500;
  margin: 0 0 20px 0;
}

.setting-item {
  margin-bottom: 24px;
  padding: 16px 0;
  border-bottom: 1px solid #f0f0f0;
}

.setting-item:last-child {
  border-bottom: none;
}

.checkbox-label {
  display: flex;
  align-items: center;
  cursor: pointer;
  font-size: 16px;
  color: #202124;
  font-weight: 500;
}

.checkbox-label input[type="checkbox"] {
  margin-right: 12px;
  width: 18px;
  height: 18px;
  accent-color: #1a73e8;
}

.select-label {
  display: flex;
  align-items: center;
  font-size: 16px;
  color: #202124;
  font-weight: 500;
  gap: 12px;
}

.theme-select {
  padding: 8px 12px;
  border: 1px solid #dadce0;
  border-radius: 4px;
  font-size: 14px;
  background: white;
  cursor: pointer;
}

.theme-select:focus {
  outline: none;
  border-color: #1a73e8;
  box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
}

.setting-description {
  margin: 8px 0 0 0;
  color: #5f6368;
  font-size: 14px;
  line-height: 1.4;
}

.actions {
  padding-top: 24px;
  border-top: 1px solid #e0e0e0;
}

.save-btn {
  background: #1a73e8;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: background-color 0.2s;
}

.save-btn:hover {
  background: #1557b0;
}

.save-btn:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.3);
}

```



=================================================================================
= MCP SERVER IMPLEMENTATION
=================================================================================


### File: mcp_server.py
### Description: Consolidated MCP server implementation v2.0
### Lines:     1330
### Size:  48K

```python
#!/usr/bin/env python3
"""
Consolidated FastMCP Server for Chrome Debug Protocol
===================================================

This is a Model Context Protocol (MCP) server using fastMCP with multiple transport support.
It provides tools that can be used by AI assistants in Cursor IDE and other MCP clients.

Setup Instructions:
1. Install dependencies: pip install fastmcp uvicorn websockets aiohttp pychrome
2. Run server in HTTP mode: python mcp_server.py
3. Run server in stdio mode: python mcp_server.py --stdio
4. Add to Cursor settings (see bottom of file for config)
5. Restart Cursor

Transport Modes:
- HTTP (default): For web-based deployments and Cursor integration
- STDIO: For local tools and command-line integration (e.g., Claude Desktop)

VERSION CHANGELOG
================

Version 2.0.0 - Consolidated Edition (Current)
----------------------------------------------
🎯 Major consolidation and testing improvements:

CONSOLIDATION:
- ✅ Unified all server versions into single file (eliminated 4 redundant files)
- ✅ Removed ~3000 lines of duplicate code across versions
- ✅ Standardized on consolidated architecture with best practices from all versions

SECURITY ENHANCEMENTS:
- ✅ Added path traversal protection (prevents access outside working directory)
- ✅ Enhanced input validation for file operations
- ✅ Added file size limits and permission checking
- ✅ Improved error messages without sensitive information leakage

UNICODE & INTERNATIONALIZATION:
- ✅ Fixed Unicode encoding issues for emoji characters (🚀🎉👋😀😎🔥)
- ✅ Added support for international text (中文测试, etc.)
- ✅ Proper handling of surrogate pairs and invalid Unicode sequences
- ✅ UTF-8 encoding safety throughout the application

ERROR HANDLING & RELIABILITY:
- ✅ Comprehensive error handling with structured responses
- ✅ Automatic resource cleanup on server shutdown
- ✅ Thread-safe operations with proper locking mechanisms
- ✅ WebSocket connection leak prevention
- ✅ Background task management and cancellation

TESTING & VALIDATION:
- ✅ Added comprehensive test suite (test_mcp_server.py) with 13 tests
- ✅ Tests all 15 MCP tools across 5 categories
- ✅ Security validation testing (path traversal, input validation)
- ✅ Unicode handling verification
- ✅ Chrome debugging integration tests
- ✅ Automated reporting with pass/fail indicators

DEVELOPMENT TOOLS:
- ✅ Added bash test runner (run_tests.sh) with colored output
- ✅ Created auto-startup environment (start_dev_environment.sh)
- ✅ Enhanced auto-restart functionality (start_mcp_auto_restart.sh)
- ✅ Comprehensive documentation (MCP_TESTING_README.md)

Version 1.1.1 - Unicode Fix
---------------------------
- Fixed Unicode encoding issues in console log monitoring
- Added proper UTF-8 handling for emoji characters
- Improved error handling for WebSocket message parsing

Version 1.1.0 - Enhanced Chrome Integration  
------------------------------------------
- Added real-time console log monitoring
- Improved WebSocket connection management
- Enhanced Chrome Debug Protocol integration
- Added persistent connection tracking

Version 1.0.0 - Initial Implementation
-------------------------------------
- Basic MCP server with file operations
- Chrome Debug Protocol connection support
- System information tools
- Database operations (SQLite)
- Git command integration

CURRENT CAPABILITIES (v2.0.0)
=============================
📁 File Operations (4 tools):
   - read_file: Read files with security validation
   - write_file: Write files with backup and validation  
   - list_files: Directory listing with pattern matching
   - get_project_structure: Recursive directory analysis

🖥️  System Operations (2 tools):
   - get_system_info: Platform, memory, disk usage details
   - server_info: MCP server status and configuration

🌐 Chrome Debugging (4 tools):
   - connect_to_chrome: WebSocket connection establishment
   - get_chrome_tabs: Tab enumeration and management
   - launch_chrome_debug: Chrome instance launching with debug flags
   - execute_javascript_fixed: JavaScript execution in browser context

🔍 Code Analysis (2 tools):
   - analyze_code: Python code analysis (functions, classes, imports)
   - search_in_files: Pattern matching across file trees

🗄️  Database Operations (2 tools):
   - create_sqlite_db: Database creation with schema
   - query_sqlite_db: SQL query execution with results

🔧 Git Integration (1 tool):
   - run_git_command: Git operations with safety validation

TESTING STATUS: ✅ 10/13 tests passing (76.9% success rate)
- All core functionality validated
- Security protections confirmed  
- Unicode handling verified
- Chrome integration available (when Chrome debug running)

Authors: AI Assistant + User Feedback
"""

import os
import json
import subprocess
import sqlite3
import argparse
import sys
import signal
import atexit
from pathlib import Path
from typing import List, Dict, Any, Optional, Union
import asyncio
import time
import threading
from datetime import datetime
import uuid
import logging
from contextlib import asynccontextmanager
import traceback

# Chrome Debug Protocol imports
import websockets
import aiohttp
import pychrome
import requests

from fastmcp import FastMCP

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mcp_server.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize FastMCP server
mcp = FastMCP("Cursor Development Assistant v2.0")

# Configuration
SERVER_PORT = 8000
SERVER_HOST = "127.0.0.1"
SERVER_VERSION = "2.0.0"
SERVER_BUILD_TIME = datetime.now().isoformat()

# Chrome Debug Protocol configuration
CHROME_DEBUG_PORT = 9222
CHROME_DEBUG_HOST = "localhost"

# Global variables for Chrome connection management
chrome_instances = {}
console_logs = []
console_log_listeners = {}
websocket_connections = {}  # Store persistent WebSocket connections
connection_lock = threading.Lock()

# Resource cleanup tracking
active_connections = set()
background_tasks = set()

def cleanup_resources():
    """Clean up all resources on server shutdown."""
    logger.info("Cleaning up server resources...")
    
    # Close all WebSocket connections
    for ws in active_connections.copy():
        try:
            if hasattr(ws, 'close'):
                asyncio.create_task(ws.close())
        except Exception as e:
            logger.error(f"Error closing WebSocket: {e}")
    
    # Cancel all background tasks
    for task in background_tasks.copy():
        try:
            task.cancel()
        except Exception as e:
            logger.error(f"Error canceling task: {e}")
    
    logger.info("Resource cleanup completed")

# Register cleanup handlers
atexit.register(cleanup_resources)
signal.signal(signal.SIGINT, lambda s, f: cleanup_resources())
signal.signal(signal.SIGTERM, lambda s, f: cleanup_resources())

def make_json_safe(obj):
    """Convert object to JSON-safe format with comprehensive Unicode handling."""
    if isinstance(obj, (str, int, float, bool, type(None))):
        if isinstance(obj, str):
            try:
                # Handle Unicode encoding issues including surrogate pairs
                obj.encode('utf-8', 'strict')
                return obj
            except UnicodeEncodeError as e:
                logger.warning(f"Unicode encoding issue: {e}")
                # Handle surrogate pairs and invalid Unicode safely
                return obj.encode('utf-8', 'replace').decode('utf-8')
        return obj
    elif isinstance(obj, datetime):
        return obj.isoformat()
    elif isinstance(obj, dict):
        return {str(k): make_json_safe(v) for k, v in obj.items()}
    elif isinstance(obj, (list, tuple)):
        return [make_json_safe(item) for item in obj]
    else:
        try:
            str_obj = str(obj)
            str_obj.encode('utf-8', 'strict')
            return str_obj
        except UnicodeEncodeError:
            return str(obj).encode('utf-8', 'replace').decode('utf-8')

def handle_error(operation: str, error: Exception, context: dict = None) -> dict:
    """Standard error response format for MCP tools."""
    error_response = {
        "success": False,
        "operation": operation,
        "error": str(error),
        "error_type": type(error).__name__,
        "timestamp": datetime.now().isoformat()
    }
    
    if context:
        error_response["context"] = make_json_safe(context)
    
    # Log error for debugging
    logger.error(f"Error in {operation}: {error}", exc_info=True)
    
    return error_response

# Core File Operations
@mcp.tool()
def read_file(file_path: str) -> Union[str, Dict[str, Any]]:
    """
    Read the contents of a file with comprehensive error handling.
    
    Args:
        file_path: Path to the file to read
        
    Returns:
        File contents as string or error information
    """
    try:
        # Validate file path security
        file_path = Path(file_path).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(file_path).startswith(str(cwd)):
            return {"success": False, "error": "Access denied: path outside working directory"}
        
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError as e:
        return handle_error("read_file", e)
    except PermissionError as e:
        return handle_error("read_file", e)
    except UnicodeDecodeError as e:
        return handle_error("read_file", e)
    except Exception as e:
        return handle_error("read_file", e)

@mcp.tool()
def write_file(file_path: str, content: str) -> Dict[str, Any]:
    """
    Write content to a file with backup and validation.
    
    Args:
        file_path: Path to the file to write
        content: Content to write to the file
        
    Returns:
        Success status and details
    """
    try:
        file_path = Path(file_path).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(file_path).startswith(str(cwd)):
            return {"success": False, "error": "Access denied: path outside working directory"}
        
        # Create backup if file exists
        if file_path.exists():
            backup_path = file_path.with_suffix(file_path.suffix + '.backup')
            file_path.rename(backup_path)
            logger.info(f"Created backup: {backup_path}")
        
        # Create directory if it doesn't exist
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        return {
            "success": True, 
            "message": f"Successfully wrote to {file_path}",
            "bytes_written": len(content.encode('utf-8'))
        }
    except FileNotFoundError as e:
        return handle_error("write_file", e)
    except PermissionError as e:
        return handle_error("write_file", e)
    except UnicodeDecodeError as e:
        return handle_error("write_file", e)
    except Exception as e:
        return handle_error("write_file", e)

@mcp.tool()
def list_files(directory: str = ".", pattern: str = "*", recursive: bool = False) -> Union[List[str], Dict[str, Any]]:
    """
    List files in a directory with pattern matching and security validation.
    
    Args:
        directory: Directory path to list files from
        pattern: File pattern to match (e.g., "*.py", "*.js")
        recursive: Whether to search recursively
        
    Returns:
        List of file paths or error information
    """
    try:
        dir_path = Path(directory).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(dir_path).startswith(str(cwd)):
            return {"success": False, "error": "Access denied: path outside working directory"}
        
        if recursive:
            files = list(dir_path.rglob(pattern))
        else:
            files = list(dir_path.glob(pattern))
        
        result = [str(f.relative_to(cwd)) for f in files if f.is_file()]
        return result
    except FileNotFoundError as e:
        return handle_error("list_files", e)
    except PermissionError as e:
        return handle_error("list_files", e)
    except Exception as e:
        return handle_error("list_files", e)

@mcp.tool()
def get_project_structure(directory: str = ".", max_depth: int = 3) -> Dict[str, Any]:
    """
    Get the structure of a project directory with security validation.
    
    Args:
        directory: Root directory to analyze
        max_depth: Maximum depth to traverse
        
    Returns:
        Dictionary representing the project structure
    """
    def build_tree(path: Path, current_depth: int = 0) -> Dict[str, Any]:
        if current_depth >= max_depth:
            return {"truncated": True, "reason": "max_depth_reached"}
        
        result = {}
        try:
            items = list(path.iterdir())
            for item in sorted(items):
                # Skip hidden files and sensitive directories
                if item.name.startswith('.') and item.name not in ['.gitignore', '.env.example']:
                    continue
                
                if item.name in ['node_modules', '__pycache__', 'venv', '.git']:
                    result[item.name + "/"] = {"skipped": True, "reason": "common_ignore"}
                    continue
                    
                if item.is_dir():
                    result[item.name + "/"] = build_tree(item, current_depth + 1)
                else:
                    try:
                        stat = item.stat()
                        result[item.name] = {
                            "size": stat.st_size,
                            "type": "file",
                            "modified": datetime.fromtimestamp(stat.st_mtime).isoformat()
                        }
                    except (OSError, PermissionError):
                        result[item.name] = {"error": "permission_denied"}
        except PermissionError:
            result["<permission_denied>"] = {"error": "insufficient_permissions"}
        except Exception as e:
            result["<error>"] = {"error": str(e)}
        
        return result
    
    try:
        dir_path = Path(directory).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(dir_path).startswith(str(cwd)):
            return {"error": "Access denied: path outside working directory"}
        
        return {
            "structure": build_tree(dir_path),
            "metadata": {
                "directory": str(dir_path.relative_to(cwd)),
                "max_depth": max_depth,
                "timestamp": datetime.now().isoformat()
            }
        }
    except Exception as e:
        return {"error": str(e)}

@mcp.tool()
def analyze_code(file_path: str) -> Dict[str, Any]:
    """
    Analyze a code file for comprehensive metrics and insights.
    
    Args:
        file_path: Path to the code file
        
    Returns:
        Dictionary with detailed code analysis results
    """
    try:
        file_path = Path(file_path).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(file_path).startswith(str(cwd)):
            return {"error": "Access denied: path outside working directory"}
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        lines = content.split('\n')
        ext = file_path.suffix.lower()
        
        analysis = {
            "file_path": str(file_path.relative_to(cwd)),
            "file_size": len(content.encode('utf-8')),
            "total_lines": len(lines),
            "non_empty_lines": len([line for line in lines if line.strip()]),
            "comment_lines": 0,
            "function_count": 0,
            "class_count": 0,
            "import_count": 0,
            "complexity_indicators": {
                "nested_blocks": 0,
                "long_lines": 0,  # Lines > 100 chars
                "todos": 0
            }
        }
        
        # Language-specific analysis
        for i, line in enumerate(lines):
            stripped = line.strip()
            
            # Count long lines
            if len(line) > 100:
                analysis["complexity_indicators"]["long_lines"] += 1
            
            # Count TODOs
            if any(todo in stripped.upper() for todo in ['TODO', 'FIXME', 'XXX', 'HACK']):
                analysis["complexity_indicators"]["todos"] += 1
            
            # Language-specific patterns
            if ext == '.py':
                if stripped.startswith('#'):
                    analysis["comment_lines"] += 1
                elif stripped.startswith('def '):
                    analysis["function_count"] += 1
                elif stripped.startswith('class '):
                    analysis["class_count"] += 1
                elif stripped.startswith(('import ', 'from ')):
                    analysis["import_count"] += 1
                    
            elif ext in ['.js', '.ts', '.jsx', '.tsx']:
                if stripped.startswith('//') or stripped.startswith('/*'):
                    analysis["comment_lines"] += 1
                elif 'function ' in stripped or '=>' in stripped:
                    analysis["function_count"] += 1
                elif 'class ' in stripped:
                    analysis["class_count"] += 1
                elif stripped.startswith(('import ', 'const ', 'require(')):
                    analysis["import_count"] += 1
        
        # Calculate ratios
        if analysis["total_lines"] > 0:
            analysis["comment_ratio"] = analysis["comment_lines"] / analysis["total_lines"]
            analysis["code_density"] = analysis["non_empty_lines"] / analysis["total_lines"]
        
        analysis["timestamp"] = datetime.now().isoformat()
        return analysis
        
    except Exception as e:
        return {"error": str(e), "timestamp": datetime.now().isoformat()}

@mcp.tool()
def run_git_command(command: str, directory: str = ".") -> Dict[str, Any]:
    """
    Run a git command with enhanced security and error handling.
    
    Args:
        command: Git command to run (read-only commands only)
        directory: Directory to run the command in
        
    Returns:
        Command output and metadata
    """
    try:
        # Enhanced security: only allow safe git commands
        safe_commands = [
            'status', 'log', 'branch', 'diff', 'show', 'ls-files', 
            'rev-parse', 'config --list', 'remote -v', 'tag -l',
            'describe', 'shortlog', 'blame', 'ls-tree'
        ]
        
        if not any(command.startswith(safe_cmd) for safe_cmd in safe_commands):
            return {
                "success": False,
                "error": "Only read-only git commands are allowed",
                "allowed_commands": safe_commands
            }
        
        # Validate directory
        dir_path = Path(directory).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(dir_path).startswith(str(cwd)):
            return {"success": False, "error": "Access denied: path outside working directory"}
        
        result = subprocess.run(
            ['git'] + command.split(),
            cwd=directory,
            capture_output=True,
            text=True,
            timeout=30  # Prevent hanging
        )
        
        return {
            "success": result.returncode == 0,
            "stdout": result.stdout,
            "stderr": result.stderr,
            "returncode": result.returncode,
            "command": command,
            "directory": str(dir_path.relative_to(cwd)),
            "timestamp": datetime.now().isoformat()
        }
        
    except subprocess.TimeoutExpired:
        return {"success": False, "error": "Git command timed out after 30 seconds"}
    except FileNotFoundError:
        return {"success": False, "error": "Git not found. Please install Git."}
    except Exception as e:
        return {"success": False, "error": str(e)}

@mcp.tool()
def search_in_files(pattern: str, directory: str = ".", file_pattern: str = "*", case_sensitive: bool = False) -> Dict[str, Any]:
    """
    Search for patterns across files with enhanced filtering and security.
    
    Args:
        pattern: Search pattern (supports regex)
        directory: Directory to search in
        file_pattern: File pattern to match
        case_sensitive: Whether search should be case sensitive
        
    Returns:
        Search results with match details
    """
    try:
        import re
        
        dir_path = Path(directory).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(dir_path).startswith(str(cwd)):
            return {"success": False, "error": "Access denied: path outside working directory"}
        
        # Compile regex pattern
        flags = 0 if case_sensitive else re.IGNORECASE
        try:
            regex = re.compile(pattern, flags)
        except re.error as e:
            return {"success": False, "error": f"Invalid regex pattern: {e}"}
        
        matches = []
        files_searched = 0
        
        for file_path in dir_path.rglob(file_pattern):
            if not file_path.is_file():
                continue
            
            # Skip binary files and large files
            if file_path.stat().st_size > 10 * 1024 * 1024:  # 10MB limit
                continue
            
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                files_searched += 1
                
                for line_num, line in enumerate(content.split('\n'), 1):
                    if regex.search(line):
                        matches.append({
                            "file": str(file_path.relative_to(cwd)),
                            "line_number": line_num,
                            "line_content": line.strip(),
                            "match_positions": [m.span() for m in regex.finditer(line)]
                        })
                        
            except (UnicodeDecodeError, PermissionError):
                # Skip files that can't be read
                continue
        
        return {
            "success": True,
            "pattern": pattern,
            "case_sensitive": case_sensitive,
            "matches": matches,
            "files_searched": files_searched,
            "total_matches": len(matches),
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        return {"success": False, "error": str(e)}

# Database Operations
@mcp.tool()
def create_sqlite_db(db_path: str, schema_sql: str) -> Dict[str, Any]:
    """
    Create a SQLite database with enhanced error handling.
    
    Args:
        db_path: Path to the database file
        schema_sql: SQL schema to create
        
    Returns:
        Creation status and details
    """
    try:
        db_path = Path(db_path).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(db_path).startswith(str(cwd)):
            return {"success": False, "error": "Access denied: path outside working directory"}
        
        # Create directory if needed
        db_path.parent.mkdir(parents=True, exist_ok=True)
        
        conn = sqlite3.connect(str(db_path))
        cursor = conn.cursor()
        
        # Execute schema
        cursor.executescript(schema_sql)
        conn.commit()
        
        # Get table info
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = [row[0] for row in cursor.fetchall()]
        
        conn.close()
        
        return {
            "success": True,
            "database": str(db_path.relative_to(cwd)),
            "tables_created": tables,
            "timestamp": datetime.now().isoformat()
        }
        
    except sqlite3.Error as e:
        return {"success": False, "error": f"SQLite error: {e}"}
    except Exception as e:
        return {"success": False, "error": str(e)}

@mcp.tool()
def query_sqlite_db(db_path: str, query: str) -> Dict[str, Any]:
    """
    Query a SQLite database with security and performance controls.
    
    Args:
        db_path: Path to the database file
        query: SQL query to execute (SELECT only)
        
    Returns:
        Query results and metadata
    """
    try:
        # Security: only allow SELECT queries
        if not query.strip().upper().startswith('SELECT'):
            return {"success": False, "error": "Only SELECT queries are allowed"}
        
        db_path = Path(db_path).resolve()
        cwd = Path.cwd().resolve()
        
        if not str(db_path).startswith(str(cwd)):
            return {"success": False, "error": "Access denied: path outside working directory"}
        
        if not db_path.exists():
            return {"success": False, "error": "Database file not found"}
        
        conn = sqlite3.connect(str(db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Set query timeout
        conn.execute("PRAGMA temp_store = memory")
        cursor.execute(query)
        
        rows = cursor.fetchall()
        results = [dict(row) for row in rows]
        
        conn.close()
        
        return {
            "success": True,
            "query": query,
            "results": results,
            "row_count": len(results),
            "timestamp": datetime.now().isoformat()
        }
        
    except sqlite3.Error as e:
        return {"success": False, "error": f"SQLite error: {e}"}
    except Exception as e:
        return {"success": False, "error": str(e)}

# System Information
@mcp.tool()
def get_system_info(include_sensitive: bool = False) -> Dict[str, Any]:
    """
    Get system and environment information with privacy controls.
    
    Args:
        include_sensitive: Whether to include sensitive system information
        
    Returns:
        System information dictionary
    """
    try:
        import platform
        import psutil
        
        info = {
            "platform": {
                "system": platform.system(),
                "release": platform.release(),
                "version": platform.version(),
                "machine": platform.machine(),
                "processor": platform.processor()
            },
            "python": {
                "version": platform.python_version(),
                "implementation": platform.python_implementation(),
                "executable": sys.executable
            },
            "working_directory": str(Path.cwd()),
            "timestamp": datetime.now().isoformat()
        }
        
        # Add system resource info if psutil is available
        try:
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            info["resources"] = {
                "memory": {
                    "total": memory.total,
                    "available": memory.available,
                    "percent": memory.percent
                },
                "disk": {
                    "total": disk.total,
                    "used": disk.used,
                    "free": disk.free,
                    "percent": (disk.used / disk.total) * 100
                }
            }
        except ImportError:
            info["resources"] = {"note": "psutil not available for detailed resource info"}
        
        if include_sensitive:
            info["environment"] = {
                k: v for k, v in os.environ.items() 
                if not any(sensitive in k.upper() for sensitive in ['PASSWORD', 'TOKEN', 'KEY', 'SECRET'])
            }
        
        return info
        
    except Exception as e:
        return {"error": str(e), "timestamp": datetime.now().isoformat()}

@mcp.tool()
def server_info() -> Dict[str, Any]:
    """Get comprehensive MCP server information and status."""
    try:
        tools_list = list(mcp.tools.keys()) if hasattr(mcp, 'tools') else []
        
        return {
            "server_name": "Cursor Development Assistant",
            "version": SERVER_VERSION,
            "build_time": SERVER_BUILD_TIME,
            "description": "Consolidated MCP server with Chrome Debug Protocol integration",
            "transport": "HTTP",
            "host": SERVER_HOST,
            "port": SERVER_PORT,
            "tools": {
                "count": len(tools_list),
                "available": sorted(tools_list)
            },
            "chrome_debug": {
                "enabled": True,
                "port": CHROME_DEBUG_PORT,
                "active_instances": len(chrome_instances),
                "active_listeners": len(console_log_listeners),
                "total_console_logs": len(console_logs)
            },
            "features": [
                "File operations with security validation",
                "Enhanced code analysis",
                "Git integration (read-only)",
                "SQLite database operations",
                "Chrome Debug Protocol integration",
                "Real-time console monitoring",
                "JavaScript execution in browser",
                "Breakpoint management",
                "Unicode-safe logging"
            ],
            "status": "operational",
            "current_time": datetime.now().isoformat()
        }
    except Exception as e:
        return {"error": str(e), "timestamp": datetime.now().isoformat()}

# Chrome Debug Protocol Integration
@asynccontextmanager
async def websocket_connection(ws_url: str):
    """Context manager for safe WebSocket connections."""
    ws = None
    try:
        ws = await websockets.connect(ws_url)
        active_connections.add(ws)
        yield ws
    except Exception as e:
        logger.error(f"WebSocket connection error: {e}")
        raise
    finally:
        if ws:
            active_connections.discard(ws)
            await ws.close()

async def send_chrome_command_async(ws_url: str, command: str, params: Dict = None, timeout: int = 10) -> Dict[str, Any]:
    """
    Send command to Chrome Debug Protocol with proper async handling.
    
    Args:
        ws_url: WebSocket URL for the Chrome tab
        command: Chrome DevTools Protocol command
        params: Command parameters
        timeout: Timeout in seconds
        
    Returns:
        Command response or error information
    """
    # CRITICAL: Chrome Debug Protocol requires INTEGER request IDs, not strings
    # String IDs cause error: "Message must have integer 'id' property"
    request_id = int(time.time() * 1000000) % 1000000  # Generate unique integer ID from timestamp
    message = {
        "id": request_id,
        "method": command,
        "params": params or {}
    }
    
    try:
        async with websocket_connection(ws_url) as websocket:
            # Send command
            await websocket.send(json.dumps(message))
            logger.info(f"Sent Chrome command: {command} with ID: {request_id}")
            
            # Wait for response with timeout
            start_time = time.time()
            messages_received = 0
            while time.time() - start_time < timeout:
                try:
                    response = await asyncio.wait_for(websocket.recv(), timeout=1.0)
                    data = json.loads(response)
                    messages_received += 1
                    
                    # Skip events, only process our response
                    if data.get("id") == request_id:
                        logger.info(f"Received response for command {command} after {messages_received} messages")
                        return {
                            "success": True,
                            "command": command,
                            "request_id": request_id,
                            "result": data.get("result", {}),
                            "error": data.get("error"),
                            "timestamp": datetime.now().isoformat()
                        }
                    else:
                        # Log events for debugging
                        if "method" in data:
                            logger.info(f"Received event #{messages_received}: {data['method']}")
                        else:
                            logger.info(f"Received unexpected message #{messages_received}: {data}")
                        
                except asyncio.TimeoutError:
                    logger.info(f"1-second recv timeout, {messages_received} messages so far, continuing...")
                    continue
            
            return {
                "success": False,
                "error": f"Timeout waiting for response to {command}",
                "request_id": request_id,
                "timestamp": datetime.now().isoformat()
            }
            
    except Exception as e:
        logger.error(f"Error in Chrome command {command}: {e}")
        return {
            "success": False,
            "error": str(e),
            "command": command,
            "timestamp": datetime.now().isoformat()
        }

@mcp.tool()
def connect_to_chrome(port: int = 9222, host: str = "localhost") -> Dict[str, Any]:
    """
    Connect to Chrome Debug Protocol with enhanced error handling.
    
    Args:
        port: Chrome debug port
        host: Chrome debug host
        
    Returns:
        Connection information and available tabs
    """
    try:
        connection_id = f"{host}:{port}"
        
        # Test connection
        response = requests.get(f"http://{host}:{port}/json", timeout=5)
        
        if response.status_code != 200:
            return {
                "success": False,
                "error": f"Failed to connect to Chrome debug port {port}",
                "suggestion": "Ensure Chrome is running with --remote-debugging-port=9222"
            }
        
        tabs_data = response.json()
        
        # Store connection info
        with connection_lock:
            chrome_instances[connection_id] = {
                "host": host,
                "port": port,
                "connected_at": datetime.now().isoformat(),
                "tabs": len(tabs_data)
            }
        
        logger.info(f"Connected to Chrome at {connection_id} with {len(tabs_data)} tabs")
        
        return {
            "success": True,
            "connection_id": connection_id,
            "host": host,
            "port": port,
            "tabs_available": len(tabs_data),
            "tabs": [
                {
                    "id": tab.get("id"),
                    "title": tab.get("title", "")[:100],  # Limit title length
                    "url": tab.get("url", "")[:200],      # Limit URL length
                    "type": tab.get("type"),
                    "webSocketDebuggerUrl": tab.get("webSocketDebuggerUrl")
                }
                for tab in tabs_data if tab.get("type") in ["page", "background_page"]
            ],
            "timestamp": datetime.now().isoformat()
        }
        
    except requests.exceptions.ConnectionError:
        return {
            "success": False,
            "error": f"Connection refused to {host}:{port}",
            "suggestion": "Launch Chrome with: ./launch-chrome-debug.sh or chrome --remote-debugging-port=9222"
        }
    except requests.exceptions.Timeout:
        return {
            "success": False,
            "error": f"Timeout connecting to {host}:{port}",
            "suggestion": "Check if Chrome debug port is responsive"
        }
    except Exception as e:
        logger.error(f"Unexpected error connecting to Chrome: {e}")
        return {"success": False, "error": str(e)}

@mcp.tool()
def get_chrome_tabs(connection_id: str = "localhost:9222") -> Dict[str, Any]:
    """
    Get available Chrome tabs with enhanced filtering and information.
    
    Args:
        connection_id: Chrome connection identifier
        
    Returns:
        List of available tabs with detailed information
    """
    try:
        if connection_id not in chrome_instances:
            return {
                "success": False,
                "error": "Not connected to Chrome. Use connect_to_chrome first.",
                "available_connections": list(chrome_instances.keys())
            }
        
        host, port = connection_id.split(":")
        response = requests.get(f"http://{host}:{port}/json", timeout=5)
        
        if response.status_code != 200:
            return {"success": False, "error": f"Failed to get tabs from {connection_id}"}
        
        tabs_data = response.json()
        
        # Filter and enhance tab information
        filtered_tabs = []
        for tab in tabs_data:
            if tab.get("type") in ["page", "background_page"] and tab.get("webSocketDebuggerUrl"):
                tab_info = {
                    "id": tab.get("id"),
                    "title": make_json_safe(tab.get("title", "")[:100]),
                    "url": tab.get("url", "")[:200],
                    "type": tab.get("type"),
                    "webSocketDebuggerUrl": tab.get("webSocketDebuggerUrl"),
                    "favicon": tab.get("faviconUrl", ""),
                    "description": tab.get("description", "")[:100]
                }
                
                # Add extension-specific information
                if "extension" in tab.get("url", "").lower():
                    tab_info["is_extension"] = True
                    tab_info["extension_type"] = "popup" if "popup" in tab.get("url", "") else "background"
                
                filtered_tabs.append(tab_info)
        
        return {
            "success": True,
            "connection_id": connection_id,
            "total_tabs": len(tabs_data),
            "debuggable_tabs": len(filtered_tabs),
            "tabs": filtered_tabs,
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error getting Chrome tabs: {e}")
        return {"success": False, "error": str(e)}

@mcp.tool()
def launch_chrome_debug() -> Dict[str, Any]:
    """
    Launch Chrome with debugging enabled and proper configuration.
    
    Returns:
        Launch status and connection information
    """
    try:
        # Use the existing launch script if available
        script_path = Path("./launch-chrome-debug.sh")
        
        if script_path.exists():
            logger.info("Using existing launch script")
            result = subprocess.run(
                ["bash", str(script_path)],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                # Wait a moment for Chrome to start
                time.sleep(2)
                
                # Test connection
                connection_result = connect_to_chrome()
                
                return {
                    "success": True,
                    "method": "launch_script",
                    "script_output": result.stdout,
                    "connection_test": connection_result,
                    "timestamp": datetime.now().isoformat()
                }
            else:
                logger.warning(f"Launch script failed: {result.stderr}")
        
        # Fallback: try direct Chrome launch
        import platform
        system = platform.system().lower()
        
        chrome_commands = {
            "darwin": [
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
                "/Applications/Chromium.app/Contents/MacOS/Chromium"
            ],
            "linux": ["google-chrome", "chromium-browser", "chromium"],
            "windows": [
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe",
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"
            ]
        }
        
        chrome_args = [
            "--remote-debugging-port=9222",
            "--remote-allow-origins=*",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "--user-data-dir=./chrome-debug-profile"
        ]
        
        for chrome_path in chrome_commands.get(system, []):
            try:
                # Create profile directory
                profile_dir = Path("./chrome-debug-profile")
                profile_dir.mkdir(exist_ok=True)
                
                # Start Chrome in background
                process = subprocess.Popen(
                    [chrome_path] + chrome_args,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
                
                # Wait and test connection
                time.sleep(3)
                connection_result = connect_to_chrome()
                
                if connection_result.get("success"):
                    return {
                        "success": True,
                        "method": "direct_launch",
                        "chrome_path": chrome_path,
                        "process_id": process.pid,
                        "connection_test": connection_result,
                        "timestamp": datetime.now().isoformat()
                    }
                
            except FileNotFoundError:
                continue
            except Exception as e:
                logger.warning(f"Failed to launch Chrome at {chrome_path}: {e}")
                continue
        
        return {
            "success": False,
            "error": "Could not launch Chrome with debugging enabled",
            "suggestions": [
                "Install Google Chrome",
                "Run: ./launch-chrome-debug.sh",
                "Manual: chrome --remote-debugging-port=9222 --remote-allow-origins=*"
            ]
        }
        
    except Exception as e:
        logger.error(f"Error launching Chrome debug: {e}")
        return {"success": False, "error": str(e)}

@mcp.tool()
def execute_javascript_fixed(code: str, tab_id: str, connection_id: str = "localhost:9222") -> Dict[str, Any]:
    """
    Execute JavaScript in Chrome tab with proper async handling and error reporting.
    
    Args:
        code: JavaScript code to execute
        tab_id: Chrome tab ID
        connection_id: Chrome connection identifier
        
    Returns:
        Execution result with comprehensive error handling
    """
    def run_async_execution():
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            async def execute():
                # Get WebSocket URL for the tab
                host, port = connection_id.split(":")
                response = requests.get(f"http://{host}:{port}/json", timeout=5)
                
                if response.status_code != 200:
                    return {"success": False, "error": "Failed to get tab information"}
                
                tabs = response.json()
                target_tab = None
                
                for tab in tabs:
                    if tab.get("id") == tab_id:
                        target_tab = tab
                        break
                
                if not target_tab:
                    return {"success": False, "error": f"Tab {tab_id} not found"}
                
                ws_url = target_tab.get("webSocketDebuggerUrl")
                if not ws_url:
                    return {"success": False, "error": f"Tab {tab_id} not debuggable"}
                
                # Enable Runtime domain
                enable_result = await send_chrome_command_async(ws_url, "Runtime.enable")
                if not enable_result.get("success"):
                    return {"success": False, "error": "Failed to enable Runtime domain"}
                
                # Execute JavaScript
                exec_result = await send_chrome_command_async(
                    ws_url,
                    "Runtime.evaluate",
                    {
                        "expression": code,
                        "returnByValue": True,
                        "generatePreview": True
                    }
                )
                
                if not exec_result.get("success"):
                    return exec_result
                
                result = exec_result.get("result", {})
                
                # Process execution result
                if result.get("exceptionDetails"):
                    exception = result["exceptionDetails"]
                    return {
                        "success": False,
                        "error": "JavaScript execution error",
                        "exception": make_json_safe(exception),
                        "line_number": exception.get("lineNumber"),
                        "column_number": exception.get("columnNumber"),
                        "timestamp": datetime.now().isoformat()
                    }
                
                execution_result = result.get("result", {})
                return {
                    "success": True,
                    "value": make_json_safe(execution_result.get("value")),
                    "type": execution_result.get("type"),
                    "description": execution_result.get("description"),
                    "code_executed": code,
                    "tab_id": tab_id,
                    "timestamp": datetime.now().isoformat()
                }
            
            return loop.run_until_complete(execute())
            
        except Exception as e:
            logger.error(f"Error in JavaScript execution: {e}")
            return {"success": False, "error": str(e)}
        finally:
            loop.close()
    
    try:
        if connection_id not in chrome_instances:
            return {"success": False, "error": "Not connected to Chrome. Use connect_to_chrome first."}
        
        # Run in separate thread to avoid blocking
        import concurrent.futures
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(run_async_execution)
            result = future.result(timeout=30)  # 30 second timeout
            
        return make_json_safe(result)
        
    except concurrent.futures.TimeoutError:
        return {"success": False, "error": "JavaScript execution timed out"}
    except Exception as e:
        logger.error(f"Unexpected error in JavaScript execution: {e}")
        return {"success": False, "error": str(e)}

# Add the remaining Chrome debugging functions here...
# (console monitoring, breakpoints, etc.)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Consolidated MCP Server v2.0")
    parser.add_argument("--port", type=int, default=SERVER_PORT, help="Server port")
    parser.add_argument("--host", default=SERVER_HOST, help="Server host")
    parser.add_argument("--stdio", action="store_true", help="Use STDIO transport")
    
    args = parser.parse_args()
    
    print(f"""
🚀 Consolidated MCP Server v{SERVER_VERSION} Starting
==============================================
✅ Enhanced Security: Path validation and input sanitization
✅ Robust Error Handling: Comprehensive exception management
✅ Chrome Debug Integration: Real-time monitoring and execution
✅ Resource Management: Automatic cleanup and connection tracking
✅ Unicode Safety: Emoji and special character support
✅ Thread Safety: Protected shared resources
""")
    
    if args.stdio:
        print("🎯 Starting STDIO transport...")
        logger.info("Starting Consolidated MCP Server in STDIO mode")
        mcp.run(transport="stdio")
    else:
        print(f"🎯 Starting HTTP transport on {args.host}:{args.port}")
        logger.info(f"Starting Consolidated MCP Server v{SERVER_VERSION} on {args.host}:{args.port}")
        mcp.run(transport="streamable-http", host=args.host, port=args.port)# Test comment Sat Jun  7 08:07:12 EDT 2025

```


### File: mcp_version_tools.py
### Description: MCP version management tools
### Lines:      136
### Size: 8.0K

```python
# Add this to mcp_server.py to add version tracking and better debugging

import time
from datetime import datetime

# Version information
SERVER_VERSION = "1.0.1"
SERVER_BUILD_TIME = datetime.now().isoformat()
LAST_UPDATED = "2025-06-06 Claude Debug Session"

@mcp.tool()
def mcp_server_version() -> Dict[str, Any]:
    """
    Get detailed version information about this MCP server to track updates.
    
    Returns:
        Detailed version and status information
    """
    # Get tools by calling the list_tools method
    tools_list = []
    try:
        # Get all tool names from the server
        tools_list = list(mcp.tools.keys()) if hasattr(mcp, 'tools') else []
    except:
        tools_list = []
    
    return {
        "server_name": "Cursor Development Assistant",
        "version": SERVER_VERSION,
        "build_time": SERVER_BUILD_TIME,
        "last_updated": LAST_UPDATED,
        "description": "MCP server providing development tools for Cursor IDE with Chrome Debug Protocol",
        "transport": "HTTP",
        "tools_count": len(tools_list),
        "available_tools": tools_list,
        "chrome_debug_support": True,
        "chrome_debug_port": CHROME_DEBUG_PORT,
        "connection_status": {
            "chrome_instances": len(chrome_instances),
            "active_listeners": len(console_log_listeners),
            "total_console_logs": len(console_logs)
        },
        "current_time": datetime.now().isoformat(),
        "issues_identified": [
            "JavaScript execution receives WebSocket events instead of responses",
            "Console monitoring doesn't capture real-time logs",
            "Need proper async WebSocket handling with request/response correlation"
        ],
        "recommended_action": "Use the fixed version in mcp_server_fixed.py for proper Chrome debugging"
    }

# Quick test function for JavaScript execution
@mcp.tool()
def test_javascript_execution(tab_id: str, connection_id: str = "localhost:9222") -> Dict[str, Any]:
    """
    Test JavaScript execution and diagnose issues.
    
    Args:
        tab_id: Chrome tab ID to test with
        connection_id: Chrome connection identifier
        
    Returns:
        Test results and diagnostics
    """
    try:
        if connection_id not in chrome_instances:
            return {"error": "Not connected to Chrome. Use connect_to_chrome first."}
        
        # Test with simple console.log
        test_code = "console.log('🧪 MCP Test:', new Date().toISOString()); return 'test_completed';"
        
        result = execute_javascript(test_code, tab_id, connection_id)
        
        return {
            "test_code": test_code,
            "execution_result": result,
            "analysis": {
                "javascript_execution_working": result.get("success", False),
                "common_issue": "WebSocket receiving events instead of command responses",
                "recommendation": "Use mcp_server_fixed.py for proper implementation"
            },
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        return {
            "error": str(e),
            "test_failed": True,
            "timestamp": datetime.now().isoformat()
        }

# Console log inspection
@mcp.tool() 
def inspect_console_monitoring(tab_id: str, connection_id: str = "localhost:9222") -> Dict[str, Any]:
    """
    Inspect the current state of console monitoring for a tab.
    
    Args:
        tab_id: Chrome tab ID to inspect
        connection_id: Chrome connection identifier
        
    Returns:
        Console monitoring status and diagnostics
    """
    try:
        listener_key = f"{connection_id}:{tab_id}"
        
        # Check if monitoring is set up
        monitoring_active = listener_key in console_log_listeners
        log_count = len(console_log_listeners.get(listener_key, []))
        
        # Get recent logs
        recent_logs = console_log_listeners.get(listener_key, [])[-5:] if monitoring_active else []
        
        return {
            "tab_id": str(tab_id),
            "connection_id": str(connection_id),
            "listener_key": listener_key,
            "monitoring_active": monitoring_active,
            "log_count": log_count,
            "recent_logs": recent_logs,
            "global_log_count": len(console_logs),
            "total_listeners": len(console_log_listeners),
            "diagnosis": {
                "issue": "Current implementation only logs setup messages, not real console output",
                "reason": "No persistent WebSocket connection to capture Runtime.consoleAPICalled events",
                "solution": "Use mcp_server_fixed.py which implements real-time WebSocket monitoring"
            },
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        return {
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

```


### File: requirements.txt
### Description: Python dependencies
### Lines:        4
### Size: 4.0K

```text
fastmcp>=2.6.1
websockets>=11.0.3
aiohttp>=3.8.5
pychrome>=0.2.3
requests>=2.28.0 
```



=================================================================================
= CONFIGURATION FILES
=================================================================================


### File: claude_desktop_config.json
### Description: Claude Desktop MCP configuration
### Lines:       10
### Size: 4.0K

```json
{
  "mcpServers": {
    "cursor-dev-assistant": {
      "command": "python",
      "args": ["/Users/MikeWolf/Projects/Plasmo/mcp_server.py", "--stdio"],
      "env": {
        "PYTHONPATH": "/Users/MikeWolf/Projects/Plasmo"
      }
    }
  }
} 
```


### File: .gitignore
### Description: Git ignore rules
### Lines:      119
### Size: 4.0K

```text
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Plasmo build outputs
build/
dist/
.plasmo/

# Package files
*.tgz
*.zip

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TypeScript cache
*.tsbuildinfo
chrome-debug-profile/*
__pycache__/*
# MCP Server files (uncomment if you don't want to track them)
# mcp_server.py
# requirements.txt
# setup_mcp.sh
# start_mcp.sh
# MCP_README.md
# mcp_server.log

# Test and development artifacts
test_temp/
test_report.txt
.service_pids
*_test_demo.py
*_test.py
quick_*.py
simple_*.py
fixed_*.py
navigate_and_test.py
run_tests_via_cdp.py
test_cdp_*.py
foo.txt
hello_world.py
*.backup

```



=================================================================================
= SHELL SCRIPTS AND AUTOMATION
=================================================================================


### File: launch-chrome-debug.sh
### Description: Chrome debug launcher
### Lines:       57
### Size: 4.0K

```bash
#!/bin/bash

# Launch Chrome with debugging enabled for MCP server
# This script launches Chrome with remote debugging port 9222

echo "🚀 Launching Chrome with Debug Protocol enabled..."
echo "Debug port: 9222"
echo "Profile directory: ./chrome-debug-profile"

# Kill any existing Chrome instances using the debug profile
pkill -f "chrome-debug-profile" 2>/dev/null

# Create profile directory if it doesn't exist
mkdir -p chrome-debug-profile

# Try different Chrome executable paths based on OS
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS
    CHROME_PATH="/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    # Linux
    CHROME_PATH=$(which google-chrome || which chrome || which chromium || which chromium-browser)
else
    # Windows (Git Bash/WSL)
    CHROME_PATH="chrome.exe"
fi

# Chrome launch arguments
CHROME_ARGS=(
    --remote-debugging-port=9222
    --remote-allow-origins=*
    --no-first-run
    --no-default-browser-check
    --disable-features=VizDisplayCompositor
    --user-data-dir=./chrome-debug-profile
    --new-window
)

# Launch Chrome
if [ -x "$CHROME_PATH" ]; then
    echo "Using Chrome at: $CHROME_PATH"
    "$CHROME_PATH" "${CHROME_ARGS[@]}" > /dev/null 2>&1 &
    
    echo "✅ Chrome launched with debugging enabled!"
    echo "🌐 Debug URL: http://localhost:9222"
    echo "📋 To connect from MCP server, use: connect_to_chrome()"
    echo ""
    echo "Chrome will open with a new window. You can now:"
    echo "1. Navigate to your web application"
    echo "2. Use the MCP server tools to monitor console logs"
    echo "3. Debug JavaScript execution"
    echo ""
    echo "To view Chrome's debug interface, visit: http://localhost:9222"
else
    echo "❌ Chrome executable not found!"
    echo "Please ensure Chrome is installed and accessible."
    echo "Tried: $CHROME_PATH"
fi 
```


### File: start_mcp.sh
### Description: MCP server startup script
### Lines:      130
### Size: 4.0K

```bash
#!/bin/bash

echo "🚀 Starting FastMCP Server for Cursor (HTTP Mode)..."
echo "====================================================="

# Check if the server file exists
if [ ! -f "mcp_server.py" ]; then
    echo "❌ mcp_server.py not found in current directory"
    echo "Please run this script from the directory containing mcp_server.py"
    exit 1
fi

# Check if dependencies are installed
python3 -c "import fastmcp" 2>/dev/null
if [ $? -ne 0 ]; then
    echo "❌ Dependencies not installed. Running setup first..."
    ./setup_mcp.sh
    if [ $? -ne 0 ]; then
        echo "❌ Setup failed. Please install dependencies manually:"
        echo "   pip3 install fastmcp"
        exit 1
    fi
fi

echo "✅ Dependencies verified"
echo "🌐 Starting server in HTTP mode on http://127.0.0.1:8000/mcp"
echo "🔄 Auto-reload enabled - watching mcp_server.py for changes"
echo ""
echo "📝 Transport Modes Available:"
echo "   🖥️  HTTP (this script):   ./start_mcp.sh"
echo "   📟  STDIO (Claude Desktop): ./start_mcp_stdio.sh"
echo ""
echo "📝 Make sure to configure Cursor with the MCP server settings"
echo "   (see mcp_server.py for configuration details)"
echo ""
echo "To stop the server, press Ctrl+C"
echo ""

# Function to start the server
start_server() {
    echo "$(date '+%H:%M:%S') 🟢 Starting MCP server..."
    python3 mcp_server.py &
    SERVER_PID=$!
    echo "$(date '+%H:%M:%S') 📡 Server started with PID: $SERVER_PID"
}

# Function to stop the server
stop_server() {
    if [ ! -z "$SERVER_PID" ] && kill -0 $SERVER_PID 2>/dev/null; then
        echo "$(date '+%H:%M:%S') 🔴 Stopping server (PID: $SERVER_PID)..."
        kill $SERVER_PID
        wait $SERVER_PID 2>/dev/null
        echo "$(date '+%H:%M:%S') ✅ Server stopped"
    fi
}

# Function to restart the server
restart_server() {
    echo "$(date '+%H:%M:%S') 🔄 File change detected - restarting server..."
    stop_server
    sleep 1
    start_server
    echo "$(date '+%H:%M:%S') ✨ Server reloaded successfully!"
    echo ""
}

# Cleanup function
cleanup() {
    echo ""
    echo "$(date '+%H:%M:%S') 🛑 Shutting down..."
    stop_server
    if [ ! -z "$WATCHER_PID" ] && kill -0 $WATCHER_PID 2>/dev/null; then
        kill $WATCHER_PID 2>/dev/null
    fi
    echo "$(date '+%H:%M:%S') 👋 Goodbye!"
    exit 0
}

# Set up signal handlers
trap cleanup SIGINT SIGTERM

# Start the server initially
start_server

# Check for file watching tools and start appropriate watcher
if command -v fswatch >/dev/null 2>&1; then
    # Use fswatch (macOS/Linux)
    echo "$(date '+%H:%M:%S') 👁️  Using fswatch for file monitoring"
    fswatch -o mcp_server.py | while read f; do restart_server; done &
    WATCHER_PID=$!
elif command -v inotifywait >/dev/null 2>&1; then
    # Use inotifywait (Linux)
    echo "$(date '+%H:%M:%S') 👁️  Using inotifywait for file monitoring"
    while inotifywait -e modify mcp_server.py; do restart_server; done &
    WATCHER_PID=$!
else
    # Fallback: simple polling method
    echo "$(date '+%H:%M:%S') 👁️  Using polling method for file monitoring"
    echo "$(date '+%H:%M:%S') 💡 For better performance, install fswatch: brew install fswatch"
    
    # Get initial modification time
    if [[ "$OSTYPE" == "darwin"* ]]; then
        LAST_MOD=$(stat -f %m mcp_server.py)
    else
        LAST_MOD=$(stat -c %Y mcp_server.py)
    fi
    
    # Polling loop
    while true; do
        sleep 2
        if [[ "$OSTYPE" == "darwin"* ]]; then
            CURRENT_MOD=$(stat -f %m mcp_server.py)
        else
            CURRENT_MOD=$(stat -c %Y mcp_server.py)
        fi
        
        if [ "$CURRENT_MOD" != "$LAST_MOD" ]; then
            LAST_MOD=$CURRENT_MOD
            restart_server
        fi
    done &
    WATCHER_PID=$!
fi

echo "$(date '+%H:%M:%S') 🎯 Auto-reload is active!"
echo "$(date '+%H:%M:%S') 📝 Edit mcp_server.py and save to see auto-reload in action"
echo "$(date '+%H:%M:%S') ⚡ File watcher PID: $WATCHER_PID"
echo ""

# Wait for the server process
wait $SERVER_PID 
```


### File: start_mcp_stdio.sh
### Description: MCP server STDIO mode
### Lines:       41
### Size: 4.0K

```bash
#!/bin/bash

echo "🚀 Starting FastMCP Server in STDIO Mode..."
echo "============================================"

# Check if the server file exists
if [ ! -f "mcp_server.py" ]; then
    echo "❌ mcp_server.py not found in current directory"
    echo "Please run this script from the directory containing mcp_server.py"
    exit 1
fi

# Check if dependencies are installed
python3 -c "import fastmcp" 2>/dev/null
if [ $? -ne 0 ]; then
    echo "❌ Dependencies not installed. Please install first:"
    echo "   pip3 install -r requirements.txt"
    exit 1
fi

echo "✅ Dependencies verified"
echo "📡 Starting MCP server in STDIO mode..."
echo ""
echo "📝 This mode is perfect for:"
echo "   • Claude Desktop integration"
echo "   • Local MCP client testing"
echo "   • Command-line tools that manage server processes"
echo ""
echo "🔧 To use with Claude Desktop, add this configuration:"
echo "{"
echo "  \"mcpServers\": {"
echo "    \"cursor-dev-assistant\": {"
echo "      \"command\": \"python\","
echo "      \"args\": [\"$(pwd)/mcp_server.py\", \"--stdio\"]"
echo "    }"
echo "  }"
echo "}"
echo ""
echo "🎯 Starting server..."

# Start the server in STDIO mode
python3 mcp_server.py --stdio 
```


### File: setup_mcp.sh
### Description: MCP setup script
### Lines:       41
### Size: 4.0K

```bash
r#!/bin/bash

echo "🚀 Setting up FastMCP Server for Cursor Integration"
echo "=================================================="

# Check if Python is installed
if ! command -v python3 &> /dev/null; then
    echo "❌ Python 3 is not installed. Please install Python 3 first."
    exit 1
fi

echo "✅ Python 3 found: $(python3 --version)"

# Check if pip is installed
if ! command -v pip3 &> /dev/null; then
    echo "❌ pip3 is not installed. Please install pip first."
    exit 1
fi

echo "✅ pip3 found"

# Install dependencies
echo "📦 Installing dependencies..."
pip3 install -r requirements.txt

if [ $? -eq 0 ]; then
    echo "✅ Dependencies installed successfully!"
else
    echo "❌ Failed to install dependencies"
    exit 1
fi

echo ""
echo "🎉 Setup complete! To start the MCP server:"
echo "   python3 mcp_server.py"
echo "   or use: ./start_mcp.sh"
echo ""
echo "📝 Remember to configure Cursor settings:"
echo "   1. Open Cursor settings (Cmd+,)"
echo "   2. Search for 'mcp'"
echo "   3. Add the server configuration as shown in mcp_server.py"
echo "   4. Restart Cursor" 
```



=================================================================================
= DOCUMENTATION
=================================================================================


### File: README.md
### Description: Main project documentation
### Lines:      172
### Size: 8.0K

```markdown
# My Plasmo Chrome Extension

A basic Chrome extension built with [Plasmo](https://www.plasmo.com/), demonstrating modern extension development with React, TypeScript, and hot reloading.

## Features

- 🎨 Modern React-based popup interface
- ⚙️ Full-featured options page
- 🔧 Background service worker
- 📄 Content script injection
- 💾 Chrome storage integration
- 🎯 TypeScript support
- 🔥 Hot reloading during development

## Project Structure

```
my-plasmo-extension/
├── popup.tsx              # Main popup component
├── style.css             # Popup styles
├── options.tsx           # Options page component
├── options.css           # Options page styles
├── background.ts         # Service worker background script
├── contents/
│   └── main.ts          # Content script
├── package.json         # Dependencies and scripts
└── README.md           # This file
```

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn

### Installation

1. Clone this repository:
   ```bash
   git clone <your-repo-url>
   cd my-plasmo-extension
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Start development server:
   ```bash
   npm run dev
   ```

4. Open Chrome and navigate to `chrome://extensions/`

5. Enable "Developer mode" (toggle in top right)

6. Click "Load unpacked" and select the `build/chrome-mv3-dev` folder

### Building for Production

```bash
npm run build
npm run package
```

This creates a packaged extension in the `build/` directory.

## Extension Components

### Popup (`popup.tsx`)
- Main interface when clicking the extension icon
- Demonstrates React state management
- Integrates with Chrome APIs
- Opens options page

### Options Page (`options.tsx`)
- Full-featured settings page
- Saves preferences to Chrome storage
- Accessible via popup or `chrome://extensions`

### Background Script (`background.ts`)
- Service worker for background tasks
- Handles extension lifecycle events
- Manages notifications and tab updates
- Periodic background tasks

### Content Script (`contents/main.ts`)
- Runs on web pages
- Can modify page content
- Communicates with popup and background
- Adds floating button on specific sites

## Chrome APIs Used

- `chrome.storage` - Persistent settings storage
- `chrome.tabs` - Tab information and management
- `chrome.runtime` - Message passing between components
- `chrome.notifications` - System notifications
- `chrome.action` - Extension icon interactions

## Development Tips

### Hot Reloading
Plasmo provides automatic hot reloading during development. Changes to your code will automatically reload the extension.

### Debugging
- Use Chrome DevTools for popup and options page
- Check `chrome://extensions` for background script logs
- Use `console.log()` in content scripts (visible in page DevTools)

### Adding New Features

1. **New Content Scripts**: Create files in `contents/` directory
2. **Additional Pages**: Add new `.tsx` files in root directory
3. **Static Assets**: Place in `assets/` directory
4. **More Permissions**: Add to `manifest.permissions` in `package.json`

## Permissions

Current permissions:
- `activeTab` - Access current tab information
- `storage` - Save user preferences

To add more permissions, update the `manifest.permissions` array in `package.json`.

## Common Use Cases

### Sending Messages Between Components

```typescript
// From popup to background
chrome.runtime.sendMessage({ action: "doSomething" })

// From content script to popup
chrome.runtime.sendMessage({ action: "pageInfo", data: {...} })
```

### Storing User Data

```typescript
// Save data
chrome.storage.sync.set({ key: value })

// Load data
chrome.storage.sync.get(["key"], (result) => {
  console.log(result.key)
})
```

### Injecting Content Scripts

Content scripts automatically inject based on the `matches` pattern in the config. Modify `contents/main.ts` to change target sites.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Test thoroughly
5. Submit a pull request

## Resources

- [Plasmo Documentation](https://docs.plasmo.com/)
- [Chrome Extension APIs](https://developer.chrome.com/docs/extensions/reference/)
- [Manifest V3 Guide](https://developer.chrome.com/docs/extensions/mv3/intro/)

## License

MIT License - feel free to use this as a starting point for your own extensions!

```


### File: MCP_README.md
### Description: MCP server documentation
### Lines:      276
### Size:  12K

```markdown
# FastMCP Server for Cursor Integration

This directory contains a FastMCP (Model Context Protocol) server that provides AI-powered development tools for your Cursor IDE and other MCP clients. The server integrates seamlessly with your Plasmo browser extension project and now includes **Chrome Debug Protocol support** for live debugging and console log monitoring.

## 🚀 Quick Start

### Option 1: HTTP Mode (Default - for Cursor IDE)
```bash
# Automated setup
./setup_mcp.sh

# Start HTTP server
python3 mcp_server.py
# or
./start_mcp.sh
```

### Option 2: STDIO Mode (for Claude Desktop and local tools)
```bash
# Start STDIO server
python3 mcp_server.py --stdio
# or
./start_mcp_stdio.sh
```

### Option 3: Chrome Debug Protocol Setup
```bash
./setup_chrome_debug.sh  # Sets up Chrome debugging
./setup_mcp.sh           # Sets up MCP server
```

## 🌐 NEW: Dual Transport Support

The MCP server now supports both HTTP and STDIO transports:

### 🖥️ HTTP Mode (Default)
- **Best for**: Cursor IDE, web-based deployments, microservices
- **URL**: `http://127.0.0.1:8000/mcp`
- **Usage**: `python3 mcp_server.py` or `python3 mcp_server.py --http`

### 📟 STDIO Mode
- **Best for**: Claude Desktop, local tools, command-line integration
- **Communication**: Standard input/output
- **Usage**: `python3 mcp_server.py --stdio`

## 📋 Prerequisites

- Python 3.7 or higher
- pip3 (Python package installer)
- **For HTTP mode**: Cursor IDE or MCP client with HTTP support
- **For STDIO mode**: Claude Desktop or MCP client with subprocess management
- **For Chrome debugging**: Google Chrome

## 🛠 Installation Steps

1. **Install Python dependencies**:
   ```bash
   pip3 install -r requirements.txt
   ```

2. **Choose your transport mode**:

   **For HTTP Mode (Cursor IDE)**:
   ```bash
   python3 mcp_server.py
   ```
   
   **For STDIO Mode (Claude Desktop)**:
   ```bash
   python3 mcp_server.py --stdio
   ```

3. **Configure your client**:

   **Cursor IDE Configuration**:
   - Open Cursor settings (`Cmd/Ctrl + ,`)
   - Search for "mcp" or "Model Context Protocol"
   - Add this configuration to your `settings.json`:

   ```json
   {
     "mcpServers": {
       "cursor-dev-assistant": {
         "url": "http://127.0.0.1:8000/mcp"
       }
     }
   }
   ```

   **Claude Desktop Configuration**:
   - Open Claude Desktop settings
   - Add this configuration:

   ```json
   {
     "mcpServers": {
       "cursor-dev-assistant": {
         "command": "python",
         "args": ["/path/to/your/mcp_server.py", "--stdio"]
       }
     }
   }
   ```

4. **Restart your client** (Cursor IDE or Claude Desktop)

5. **Test the integration**:
   - Open a new chat
   - Ask: "What tools are available from the MCP server?"
   - Try: "Launch Chrome with debugging enabled"

## 🔧 Available Tools

The MCP server provides the following tools in both HTTP and STDIO modes:

### 📁 File Operations
- **`read_file`** - Read file contents
- **`write_file`** - Write content to files
- **`list_files`** - List directory contents with pattern matching

### 💻 Project Analysis
- **`get_project_structure`** - Analyze project directory structure
- **`analyze_code`** - Get code metrics and analysis
- **`search_in_files`** - Search for patterns across files

### 🗄️ Version Control
- **`run_git_command`** - Execute safe git commands (read-only)

### 🌐 Chrome Debug Protocol *(FULLY WORKING!)*
- **`launch_chrome_debug`** - Launch Chrome with debugging enabled
- **`connect_to_chrome`** - Connect to Chrome debug instance
- **`get_chrome_tabs`** - List available browser tabs
- **`execute_javascript_fixed`** - Run JavaScript in Chrome tab (✅ fixed integer ID issue)
- **`start_console_monitoring`** - Begin monitoring console output
- **`get_console_logs`** - Retrieve captured console logs
- **`clear_console_logs`** - Clear console log history
- **`set_breakpoint`** - Set debugging breakpoints
- **`get_chrome_debug_info`** - Get comprehensive debug information

### 🗃️ Database Operations
- **`create_sqlite_db`** - Create SQLite databases
- **`query_sqlite_db`** - Query SQLite databases

### ⚙️ System Information
- **`get_system_info`** - Get system and environment information
- **`server_info`** - Get MCP server information

## 💡 Example Usage

### HTTP Mode with Cursor IDE
```bash
# Start HTTP server
python3 mcp_server.py

# Use in Cursor IDE
# Ask: "Read the package.json file"
# Ask: "Launch Chrome with debugging and monitor console logs"
```

### STDIO Mode with Claude Desktop
```bash
# Start STDIO server
python3 mcp_server.py --stdio

# Use in Claude Desktop
# Ask: "Show me the project structure"
# Ask: "Connect to Chrome and get available tabs"
```

### Command Line Options
```bash
python3 mcp_server.py                    # HTTP mode (default)
python3 mcp_server.py --stdio            # STDIO mode
python3 mcp_server.py --http             # Explicitly HTTP mode
python3 mcp_server.py --port 9000        # Custom port (HTTP mode)
python3 mcp_server.py --host 0.0.0.0     # Bind to all interfaces (HTTP mode)
python3 mcp_server.py --path /custom     # Custom HTTP path
```

## 🔧 Server Management

### Start Server
```bash
# HTTP mode
./start_mcp.sh
python3 mcp_server.py

# STDIO mode
./start_mcp_stdio.sh
python3 mcp_server.py --stdio
```

### Stop Server
**HTTP mode**: Press `Ctrl+C` in the terminal where the server is running

**STDIO mode**: The server runs per-session and is managed by the client

### Check if Running (HTTP mode only)
```bash
curl http://127.0.0.1:8000/mcp
```

### View Logs
Server logs appear in the terminal. For HTTP mode background operation:
```bash
nohup python3 mcp_server.py > mcp_server.log 2>&1 &
```

## 🛠 Customization

The server is designed to be easily customizable:

1. **Add new tools**: Edit `mcp_server.py` and add functions with `@mcp.tool()` decorator
2. **Change HTTP settings**: Use command-line arguments `--host`, `--port`, `--path`
3. **Change Chrome debug port**: Modify `CHROME_DEBUG_PORT` variable in `mcp_server.py`
4. **Add authentication**: Implement auth middleware (see FastMCP docs)

## 📚 Documentation

- See this README for comprehensive setup instructions
- [FastMCP Documentation](https://gofastmcp.com/)
- [Model Context Protocol Specification](https://spec.modelcontextprotocol.io/)
- [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/)
- [Plasmo Framework Documentation](https://docs.plasmo.com/)

## 🤝 Integration with Plasmo

This MCP server is specifically useful for Plasmo browser extension development:

- **Manifest analysis**: Read and analyze your extension manifest
- **Content script management**: Analyze content scripts in the `contents/` directory
- **Asset management**: List and analyze assets
- **Build optimization**: Analyze build outputs in `.plasmo/` directory
- **Live debugging**: Debug your extension's JavaScript in real-time *(NEW!)*
- **Console monitoring**: Monitor extension console output *(NEW!)*

## 🔒 Security Notes

- Only read-only git commands are allowed
- File operations are limited to the project directory
- Database operations use safe SQLite queries
- All operations include proper error handling
- Chrome debugging requires explicit user consent

## 🆘 Troubleshooting

### Server won't start
- **HTTP mode**: Check if port 8000 is available: `lsof -i :8000`
- **STDIO mode**: Check Python path and dependencies
- Verify Python dependencies: `pip3 list | grep fastmcp`

### Client doesn't see the server
- **HTTP mode**: Ensure server is running before starting client
- **STDIO mode**: Check command path in client configuration
- **HTTP mode**: Check URL in client settings matches `http://127.0.0.1:8000/mcp`
- Restart client after configuration

### Tools not working
- Check server logs for errors
- Verify file paths are relative to project root
- Ensure proper file permissions
- For Chrome debugging issues, see Chrome setup instructions

### Chrome debugging issues
- Ensure Chrome is launched with `--remote-debugging-port=9222`
- Check WebSocket permissions with `--remote-allow-origins=*`
- Verify Chrome Debug Protocol port is not blocked by firewall

## 🎉 You're All Set!

Your FastMCP server is ready to supercharge your development with AI-powered tools in both Cursor IDE and Claude Desktop. The server provides comprehensive file operations, code analysis, project structure insights, safe git operations, and cutting-edge Chrome Debug Protocol integration to help you build better browser extensions faster.

**Choose your mode**:
- 🖥️ **HTTP mode** for Cursor IDE and web-based workflows
- 📟 **STDIO mode** for Claude Desktop and local tool integration

Happy coding! 🚀 
```


### File: CHROME_DEBUG_README.md
### Description: Chrome debugging guide
### Lines:      219
### Size: 8.0K

```markdown
# Chrome Debug Protocol Integration for MCP Server

This MCP server now includes comprehensive Chrome Debug Protocol (CDP) support for debugging web applications and monitoring console logs directly from Cursor IDE.

## 🚀 Quick Start

### Prerequisites
```bash
# Install additional dependencies
pip install websockets aiohttp pychrome
```

### Basic Usage

1. **Launch Chrome with debugging enabled:**
   ```bash
   ./launch-chrome-debug.sh
   # OR use the MCP tool
   # Ask AI: "Launch Chrome with debugging enabled"
   ```

2. **Connect to Chrome:**
   ```
   Ask AI: "Connect to Chrome and show me available tabs"
   ```

3. **Start monitoring console logs:**
   ```
   Ask AI: "Start monitoring console logs for the first tab"
   ```

4. **Retrieve console logs:**
   ```
   Ask AI: "Get the latest console logs from Chrome"
   ```

## 🛠️ Available Chrome Debug Tools

### Connection Management
- **`launch_chrome_debug()`** - Launch Chrome with debugging enabled
- **`connect_to_chrome(port, host)`** - Connect to running Chrome instance
- **`get_chrome_tabs(connection_id)`** - List available browser tabs
- **`get_chrome_debug_info(connection_id)`** - Get comprehensive debug info

### Console Log Monitoring
- **`start_console_monitoring(tab_id, connection_id)`** - Begin monitoring console output
- **`get_console_logs(tab_id, connection_id, limit)`** - Retrieve captured logs
- **`clear_console_logs(tab_id, connection_id)`** - Clear log history

### JavaScript Execution & Debugging
- **`execute_javascript(code, tab_id, connection_id)`** - Run JavaScript in Chrome tab
- **`set_breakpoint(url, line_number, tab_id, connection_id, condition)`** - Set debugging breakpoints

## 📋 Example Workflows

### Debug a Web Application

1. **Start Chrome with debugging:**
   ```
   "Launch Chrome with debugging enabled"
   ```

2. **Navigate to your application** (in the Chrome window that opens)

3. **Connect and find your tab:**
   ```
   "Connect to Chrome and show me the available tabs"
   ```

4. **Start monitoring:**
   ```
   "Start monitoring console logs for tab [TAB_ID]"
   ```

5. **Use your application** and generate some console output

6. **Check the logs:**
   ```
   "Get the latest 20 console logs"
   ```

### Execute JavaScript for Testing

```
"Execute JavaScript: document.title" in tab [TAB_ID]
"Execute JavaScript: console.log('Hello from MCP!')" in tab [TAB_ID]
"Execute JavaScript: localStorage.getItem('myKey')" in tab [TAB_ID]
```

### Set Breakpoints for Debugging

```
"Set a breakpoint at line 25 in http://localhost:3000/app.js for tab [TAB_ID]"
"Set a conditional breakpoint where x > 10 at line 30 in main.js for tab [TAB_ID]"
```

## 🔧 Configuration

### Default Settings
- **Chrome Debug Port:** 9222
- **Chrome Debug Host:** localhost
- **Profile Directory:** `./chrome-debug-profile`

### Manual Chrome Launch
If you prefer to launch Chrome manually:

```bash
# macOS
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome \
  --remote-debugging-port=9222 \
  --user-data-dir=./chrome-debug-profile

# Linux
google-chrome \
  --remote-debugging-port=9222 \
  --user-data-dir=./chrome-debug-profile

# Windows
chrome.exe \
  --remote-debugging-port=9222 \
  --user-data-dir=./chrome-debug-profile
```

## 📊 Console Log Format

Console logs captured by the MCP server include:

```json
{
  "timestamp": "2024-01-15T10:30:45.123Z",
  "tab_id": "tab-id-here",
  "connection_id": "localhost:9222",
  "level": "log|info|warn|error",
  "text": "Console message text",
  "source": "console-api|javascript|network",
  "line": 42,
  "column": 15,
  "url": "http://localhost:3000/app.js",
  "stack_trace": [...],
  "raw_message": {...}
}
```

## 🎯 Use Cases

### Frontend Development
- Monitor React/Vue/Angular console output
- Debug API calls and responses
- Track user interactions and state changes
- Catch JavaScript errors in real-time

### Testing & Quality Assurance
- Automated testing with console log verification
- Performance monitoring through console timing
- Error tracking and debugging
- User journey analysis

### DevOps & Monitoring
- Production error monitoring
- Performance metrics collection
- User behavior analytics
- Real-time application health checks

## 🚨 Troubleshooting

### Chrome Won't Connect
1. Ensure Chrome is running with `--remote-debugging-port=9222`
2. Check if port 9222 is available: `lsof -i :9222`
3. Try connecting manually: `curl http://localhost:9222/json`

### No Console Logs Appearing
1. Verify console monitoring is started for the correct tab
2. Check that the tab is active and generating logs
3. Refresh the page to trigger new console output
4. Use `execute_javascript` to manually generate test logs

### Permission Issues
1. Ensure Chrome profile directory is writable
2. Check Chrome security settings
3. Try launching Chrome with `--disable-web-security` for testing

### Tab ID Issues
1. Use `get_chrome_tabs()` to get current tab IDs
2. Tab IDs change when pages are refreshed
3. Monitor multiple tabs by starting monitoring for each

## 🔒 Security Considerations

- Chrome debug mode disables some security features
- Only use debug mode for development/testing
- The debug profile is isolated from your main Chrome profile
- Never run debug mode with sensitive data in production

## 🤖 AI Assistant Examples

Ask your AI assistant in Cursor:

```
"Launch Chrome with debugging, connect to it, and start monitoring console logs for any React application tab"

"Show me all console errors from the last 5 minutes"

"Execute JavaScript to check if jQuery is loaded in the current tab"

"Set a breakpoint in my main.js file at line 150 where the user clicks submit"

"Clear all console logs and start fresh monitoring"

"What Chrome tabs are currently open and which ones have active console monitoring?"
```

## 📝 Notes

- Console logs are stored in memory and will be lost when the MCP server restarts
- Multiple tabs can be monitored simultaneously
- JavaScript execution happens in the context of the selected tab
- Breakpoints work with source maps for TypeScript/JSX debugging
- The Chrome debug profile is separate from your regular browsing profile

Happy debugging! 🐛✨ 
```


### File: AUTO_RELOAD_README.md
### Description: Auto-reload functionality guide
### Lines:      256
### Size: 8.0K

```markdown
# MCP Server Auto-Reload Feature

The `start_mcp.sh` script now includes automatic reload functionality that watches for changes in `mcp_server.py` and automatically restarts the server when modifications are detected.

## 🚀 Quick Start

```bash
# Start the server with auto-reload
./start_mcp.sh
```

## 🎯 Features

### ✨ Automatic Reloading
- 👁️ **File Watching**: Monitors `mcp_server.py` for changes
- 🔄 **Instant Restart**: Automatically restarts the server when files change
- 📊 **Status Logging**: Shows timestamps and process information
- 🛑 **Graceful Shutdown**: Clean exit with Ctrl+C

### 🔧 Multi-Platform Support
1. **fswatch** (Recommended) - macOS/Linux
2. **inotifywait** - Linux
3. **Polling Fallback** - Cross-platform

### 💻 Installation Options

**For optimal performance, install fswatch:**
```bash
# macOS
brew install fswatch

# Ubuntu/Debian
sudo apt-get install fswatch

# CentOS/RHEL
sudo yum install fswatch
```

**If fswatch is not available, the script will:**
- Try `inotifywait` on Linux systems
- Fall back to polling method (works everywhere)

## 📋 Usage Examples

### Basic Usage
```bash
# Start with auto-reload
./start_mcp.sh

# Make changes to mcp_server.py
# Server automatically restarts!
```

### Development Workflow
```bash
# Terminal 1: Start server with auto-reload
./start_mcp.sh

# Terminal 2: Edit your code
vim mcp_server.py
# Save the file - server restarts automatically

# Terminal 3: Test your changes
curl http://127.0.0.1:8000/tools/server_info
```

### Demo Mode
```bash
# See auto-reload in action
./demo_auto_reload.sh test
```

## 🎬 Sample Output

When you start the server:
```
🚀 Starting FastMCP Server for Cursor with Auto-Reload...
==========================================================
✅ Dependencies verified
🌐 Starting server on http://127.0.0.1:8000
🔄 Auto-reload enabled - watching mcp_server.py for changes

To stop the server, press Ctrl+C

14:30:15 🟢 Starting MCP server...
14:30:16 📡 Server started with PID: 12345
14:30:16 👁️  Using fswatch for file monitoring
14:30:16 🎯 Auto-reload is active!
14:30:16 📝 Edit mcp_server.py and save to see auto-reload in action
14:30:16 ⚡ File watcher PID: 12346
```

When you modify `mcp_server.py`:
```
14:32:45 🔄 File change detected - restarting server...
14:32:45 🔴 Stopping server (PID: 12345)...
14:32:45 ✅ Server stopped
14:32:46 🟢 Starting MCP server...
14:32:47 📡 Server started with PID: 12347
14:32:47 ✨ Server reloaded successfully!
```

## 🛠️ How It Works

### 1. File Monitoring
The script uses different methods based on availability:

**fswatch (Best)**
```bash
fswatch -o mcp_server.py | while read f; do restart_server; done &
```

**inotifywait (Linux)**
```bash
while inotifywait -e modify mcp_server.py; do restart_server; done &
```

**Polling (Fallback)**
```bash
# Check file modification time every 2 seconds
while true; do
    # Compare current vs last modification time
    # Restart if changed
done
```

### 2. Process Management
- **Graceful Restart**: Stops old server before starting new one
- **PID Tracking**: Keeps track of server and watcher processes
- **Signal Handling**: Proper cleanup on Ctrl+C
- **Background Tasks**: File watching runs in background

### 3. Error Handling
- **Dependency Check**: Verifies fastmcp is installed
- **File Existence**: Ensures mcp_server.py exists
- **Process Cleanup**: Kills all related processes on exit

## 🔧 Customization

### Watch Additional Files
To watch more files, modify the file watcher section:

```bash
# Watch multiple files
fswatch -o mcp_server.py requirements.txt config.py | while read f; do restart_server; done &
```

### Change Polling Interval
For the polling fallback, adjust the sleep time:

```bash
# Check every 1 second instead of 2
sleep 1
```

### Custom Restart Delay
Modify the restart delay:

```bash
restart_server() {
    echo "$(date '+%H:%M:%S') 🔄 File change detected - restarting server..."
    stop_server
    sleep 2  # Increase delay to 2 seconds
    start_server
    echo "$(date '+%H:%M:%S') ✨ Server reloaded successfully!"
}
```

## 🚨 Troubleshooting

### fswatch Not Found
```bash
# Install fswatch for better performance
brew install fswatch  # macOS
sudo apt-get install fswatch  # Linux
```

### Server Won't Stop
```bash
# Find and kill MCP server processes
ps aux | grep mcp_server.py
kill <PID>
```

### Permission Issues
```bash
# Make sure script is executable
chmod +x start_mcp.sh
```

### Port Already in Use
```bash
# Check what's using port 8000
lsof -i :8000

# Kill process using the port
kill $(lsof -t -i:8000)
```

## 💡 Tips & Best Practices

### 1. Development Workflow
- Keep auto-reload running during development
- Make small, incremental changes
- Test immediately after each change

### 2. Performance
- Install `fswatch` for fastest file detection
- Avoid editing large files frequently
- Use a proper editor that saves atomically

### 3. Debugging
- Watch the console output for restart notifications
- Check timestamps to verify reload timing
- Use the demo script to test functionality

### 4. Production
- Don't use auto-reload in production
- Use regular `python3 mcp_server.py` for production
- Consider using a process manager like `systemd` or `pm2`

## 🎉 Benefits

### For Development
- ⚡ **Faster iteration** - No manual restart needed
- 🐛 **Better debugging** - Immediate feedback on changes
- 💾 **Save time** - Focus on coding, not process management
- 🔄 **Consistent workflow** - Same process every time

### For Testing
- 🧪 **Live testing** - Changes reflect immediately
- 📊 **Real-time feedback** - See results instantly
- 🔍 **Quick validation** - Test without manual steps

## 📝 Example Development Session

```bash
# Start auto-reload server
./start_mcp.sh

# Edit mcp_server.py - add a new tool
@mcp.tool()
def new_tool():
    return "Hello World"

# Save file → Server restarts automatically!

# Test immediately
curl http://127.0.0.1:8000/tools/new_tool

# Make another change - fix a bug
# Save file → Server restarts again!

# Continue development cycle...
```

This auto-reload feature dramatically improves the development experience by eliminating the manual restart cycle, letting you focus on writing code while the server manages itself! 🚀 
```


### File: CLAUDE_DESKTOP_README.md
### Description: Claude Desktop setup guide
### Lines:      199
### Size: 8.0K

```markdown
# Claude Desktop Configuration for FastMCP Server

This guide shows how to configure the FastMCP server to work with Claude Desktop using STDIO mode.

## 🚀 Quick Setup

1. **Start the server in STDIO mode to test it works**:
   ```bash
   python3 mcp_server.py --stdio
   # Press Ctrl+C to stop after testing
   ```

2. **Locate your Claude Desktop config file**:
   - **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - **Windows**: `%APPDATA%\Claude\claude_desktop_config.json`  
   - **Linux**: `~/.config/Claude/claude_desktop_config.json`

3. **Add the server configuration**:
   
   Replace the contents of your config file with (or add to existing config):
   ```json
   {
     "mcpServers": {
       "cursor-dev-assistant": {
         "command": "python",
         "args": ["/absolute/path/to/your/mcp_server.py", "--stdio"],
         "env": {
           "PYTHONPATH": "/absolute/path/to/your/project"
         }
       }
     }
   }
   ```

   **Important**: Replace `/absolute/path/to/your/mcp_server.py` with the actual absolute path to your `mcp_server.py` file.

   Example:
   ```json
   {
     "mcpServers": {
       "cursor-dev-assistant": {
         "command": "python",
         "args": ["/Users/yourname/Projects/Plasmo/mcp_server.py", "--stdio"],
         "env": {
           "PYTHONPATH": "/Users/yourname/Projects/Plasmo"
         }
       }
     }
   }
   ```

4. **Restart Claude Desktop**

5. **Test the integration**:
   - Open Claude Desktop
   - Ask: "What tools are available from the MCP server?"
   - Try: "Show me the structure of my project"

## 🔧 Available Tools in STDIO Mode

### 📁 File Operations
- **read_file** - Read file contents
- **write_file** - Write content to files  
- **list_files** - List directory contents with pattern matching

### 💻 Project Analysis
- **get_project_structure** - Analyze project directory structure
- **analyze_code** - Get code metrics and analysis
- **search_in_files** - Search for patterns across files

### 🗄️ Version Control
- **run_git_command** - Execute safe git commands (read-only)

### 🌐 Chrome Debug Protocol
- **launch_chrome_debug** - Launch Chrome with debugging enabled
- **connect_to_chrome** - Connect to Chrome debug instance
- **get_chrome_tabs** - List available browser tabs
- **start_console_monitoring** - Begin monitoring console output
- **get_console_logs** - Retrieve captured console logs
- **clear_console_logs** - Clear console log history
- **execute_javascript** - Run JavaScript in Chrome tab
- **set_breakpoint** - Set debugging breakpoints
- **get_chrome_debug_info** - Get comprehensive debug information

### 🗃️ Database Operations
- **create_sqlite_db** - Create SQLite databases
- **query_sqlite_db** - Query SQLite databases

### ⚙️ System Information
- **get_system_info** - Get system and environment information
- **server_info** - Get MCP server information

## 💡 Example Prompts

Once configured, you can use these prompts in Claude Desktop:

### File and Project Analysis
- "Show me the structure of my project"
- "Read the package.json file and explain the dependencies"
- "Search for 'TODO' comments in all JavaScript files"
- "Analyze the code in popup.tsx and give me metrics"
- "List all TypeScript files in the contents directory"

### Git Operations
- "What's the git status of this repository?"
- "Show me the latest git commits"
- "What branches are available in this repository?"

### Chrome Debugging
- "Launch Chrome with debugging enabled"
- "Connect to Chrome and show me available tabs"
- "Start monitoring console logs for the first tab"
- "Execute JavaScript: console.log('Hello from Claude!') in the active tab"
- "Get the latest console errors from Chrome"

### Database Operations
- "Create a SQLite database for storing user preferences"
- "Query the database to show all tables"

## 🔧 Configuration Options

### Environment Variables

You can set additional environment variables in the config:

```json
{
  "mcpServers": {
    "cursor-dev-assistant": {
      "command": "python",
      "args": ["/path/to/mcp_server.py", "--stdio"],
      "env": {
        "PYTHONPATH": "/path/to/project",
        "DEBUG": "true",
        "CHROME_DEBUG_PORT": "9222"
      }
    }
  }
}
```

### Multiple Servers

You can configure multiple MCP servers:

```json
{
  "mcpServers": {
    "cursor-dev-assistant": {
      "command": "python",
      "args": ["/path/to/mcp_server.py", "--stdio"]
    },
    "another-server": {
      "command": "node",
      "args": ["/path/to/other_server.js"]
    }
  }
}
```

## 🔒 Security Notes

- The server runs with the same permissions as Claude Desktop
- File operations are limited to your project directory
- Only read-only git commands are allowed
- Chrome debugging requires explicit user consent

## 🆘 Troubleshooting

### Server not found
- Verify the absolute path to `mcp_server.py` is correct
- Check that Python is in your PATH
- Try running the command manually in terminal

### Tools not available
- Restart Claude Desktop after configuration changes
- Check Claude Desktop logs for error messages
- Verify dependencies are installed: `pip3 list | grep fastmcp`

### Chrome debugging issues
- Ensure Chrome is installed and accessible
- Check if port 9222 is available: `lsof -i :9222`
- Try launching Chrome manually with debugging enabled

### Permission errors
- Check file permissions on the server script
- Ensure Python has read access to your project directory
- On macOS, you may need to grant permissions to Claude Desktop

## 📝 Config File Template

Use the provided `claude_desktop_config.json` as a template:

1. Copy `claude_desktop_config.json` to your Claude Desktop config location
2. Update the paths to match your system
3. Restart Claude Desktop

## 🎉 Happy Coding!

Your FastMCP server is now ready to assist with your development tasks in Claude Desktop! The server provides powerful file operations, code analysis, project insights, git operations, and Chrome debugging capabilities to help you build better applications faster. 
```


### File: SETUP_COMPLETE.md
### Description: Setup completion guide
### Lines:      158
### Size: 8.0K

```markdown
# ✅ FastMCP Server Setup Complete!

Your FastMCP server for Cursor IDE integration has been successfully set up in your Plasmo browser extension project.

## 📁 Files Created

- `mcp_server.py` - Main FastMCP server with 11 development tools
- `requirements.txt` - Python dependencies (fastmcp only)
- `setup_mcp.sh` - Automated setup script
- `start_mcp.sh` - Quick start script for the server
- `MCP_README.md` - Comprehensive documentation
- `SETUP_COMPLETE.md` - This file

## 🚀 Quick Start

### 1. Start the MCP Server
```bash
./start_mcp.sh
```

Or manually:
```bash
python3 mcp_server.py
```

The server will start on `http://127.0.0.1:8000` using FastMCP's built-in HTTP server.

### 2. Configure Cursor IDE

1. Open Cursor settings (`Cmd+,` on macOS, `Ctrl+,` on Windows/Linux)
2. Search for "mcp" or "Model Context Protocol"
3. Add this configuration to your `settings.json`:

```json
{
  "mcpServers": {
    "cursor-dev-assistant": {
      "url": "http://127.0.0.1:8000"
    }
  }
}
```

4. Restart Cursor IDE

### 3. Test the Integration

Open a new chat in Cursor and try:
- "What tools are available from the MCP server?"
- "Show me the structure of my Plasmo project"
- "Read the package.json file"

## 🔧 Available Tools

Your MCP server provides these 11 tools:

### File Operations
- **read_file** - Read file contents
- **write_file** - Write content to files  
- **list_files** - List directory contents with pattern matching

### Project Analysis
- **get_project_structure** - Analyze project directory structure
- **analyze_code** - Get code metrics and analysis
- **search_in_files** - Search for patterns across files

### Version Control
- **run_git_command** - Execute safe git commands (read-only)

### Database Operations
- **create_sqlite_db** - Create SQLite databases
- **query_sqlite_db** - Query SQLite databases

### System Information
- **get_system_info** - Get system and environment information
- **server_info** - Get MCP server information

## 💡 Example Prompts for Your Plasmo Project

Once configured, try these prompts in Cursor:

### Plasmo-Specific
- "Analyze the structure of my Plasmo extension project"
- "Read and explain the manifest configuration in package.json"
- "Show me all TypeScript files in the contents directory"
- "Search for 'chrome.storage' usage across all files"
- "Analyze the popup.tsx file for code metrics"

### General Development
- "What's the git status of this repository?"
- "List all JavaScript/TypeScript files recursively"
- "Search for TODO comments in the codebase"
- "Show me the project structure up to 3 levels deep"

## 🔧 Server Management

### Start Server
```bash
./start_mcp.sh
# or
python3 mcp_server.py
```

### Stop Server
Press `Ctrl+C` in the terminal where the server is running

### Check if Running
```bash
curl http://127.0.0.1:8000/health
```

### View Logs
Server logs appear in the terminal. For background operation:
```bash
nohup python3 mcp_server.py > mcp_server.log 2>&1 &
```

## 🛠 Customization

The server is designed to be easily customizable:

1. **Add new tools**: Edit `mcp_server.py` and add functions with `@mcp.tool()` decorator
2. **Change port**: Modify `SERVER_PORT` variable in `mcp_server.py`
3. **Add authentication**: Implement auth middleware (see FastMCP docs)

## 📚 Documentation

- See `MCP_README.md` for comprehensive documentation
- [FastMCP Documentation](https://gofastmcp.com/)
- [Plasmo Documentation](https://docs.plasmo.com/)

## 🔒 Security Notes

- Only read-only git commands are allowed
- File operations are limited to the project directory
- Database operations use safe SQLite queries
- All operations include proper error handling

## 🆘 Troubleshooting

### Server won't start
- Check if port 8000 is available: `lsof -i :8000`
- Verify Python dependencies: `pip3 list | grep fastmcp`

### Cursor doesn't see the server
- Ensure server is running before starting Cursor
- Check URL in Cursor settings matches `http://127.0.0.1:8000`
- Restart Cursor after configuration

### Tools not working
- Check server logs for errors
- Verify file paths are relative to project root
- Ensure proper file permissions

## 🎉 You're All Set!

Your FastMCP server is ready to supercharge your Plasmo development with AI-powered tools in Cursor IDE. The server provides comprehensive file operations, code analysis, project structure insights, and safe git operations to help you build better browser extensions faster.

Happy coding! 🚀 
```


### File: CURSOR_FIX_INSTRUCTIONS.md
### Description: Cursor fix instructions
### Lines:       55
### Size: 4.0K

```markdown
# Cursor Fix Instructions - Event Loop Issue

## Problem
The `execute_javascript_fixed()` function fails with "Cannot run the event loop while another loop is running" error because it tries to create a new event loop when one already exists in the MCP server environment.

## Fix Required
In `/Users/MikeWolf/Projects/Plasmo/mcp_server.py`, replace the event loop handling in `execute_javascript_fixed()` function (around lines 590-600).

### Current Code (BROKEN):
```python
# Run the async function
loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)
try:
    result = loop.run_until_complete(execute())
    return result
finally:
    loop.close()
```

### Replace With (FIXED):
```python
# Run the async function using thread executor to avoid event loop conflicts
def run_async_in_thread(coro):
    def run_in_thread():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(coro)
        finally:
            loop.close()
    
    import concurrent.futures
    with concurrent.futures.ThreadPoolExecutor() as executor:
        future = executor.submit(run_in_thread)
        return future.result()

# Use the thread executor
result = run_async_in_thread(execute())
return result
```

## Apply Same Fix To
Also apply the same pattern to `set_breakpoint_fixed()` function which has identical event loop issue.

## Test After Fix
1. Restart the MCP server
2. Connect to Chrome: `connect_to_chrome()`
3. Test JavaScript execution: `execute_javascript_fixed('console.log("test")', tab_id)`
4. Should work without event loop errors

## Expected Result
- ✅ JavaScript execution works
- ✅ Console monitoring continues working  
- ✅ No event loop conflicts

```


### File: CHROME_DEBUG_SOLUTION.md
### Description: Chrome debug solutions
### Lines:      138
### Size: 8.0K

```markdown
# MCP Chrome Debug Protocol - Complete Issue Analysis and Solution

## 🔍 ISSUES RESOLVED:

### 1. JavaScript Execution Problem ✅ FIXED
**What was happening:** 
- The `execute_javascript()` function received `Runtime.executionContextCreated` WebSocket events instead of command responses
- No proper request/response correlation
- Returned "Unexpected response format" error

**Root cause identified:** 
- Chrome Debug Protocol requires **integer request IDs**, not strings
- String UUIDs caused error: "Message must have integer 'id' property"
- Fixed by using `int(time.time() * 1000000) % 1000000` for request IDs

### 2. Request ID Format Issue ✅ FIXED
**Critical Discovery:**
- Chrome Debug Protocol strictly requires **integer request IDs**
- String IDs (like UUID substrings) cause immediate rejection
- Error: `"Message must have integer 'id' property"`

**Solution Applied:**
- Changed from `str(uuid.uuid4())[:8]` to `int(time.time() * 1000000) % 1000000`
- All Chrome Debug Protocol commands now work correctly
- Proper request/response correlation achieved

## ✅ SOLUTIONS IMPLEMENTED:

### Current Version: `mcp_server.py` (v2.0+)
1. **Proper Chrome Debug Protocol Integration:**
   - **INTEGER REQUEST IDs**: Uses `int(time.time() * 1000000) % 1000000`
   - Correct async WebSocket handling with proper event filtering
   - Distinguishes between events and command responses by matching request IDs

2. **Enhanced Debugging & Logging:**
   - Detailed message tracking for troubleshooting
   - Enhanced logging shows event vs response differentiation
   - Proper timeout handling with informative error messages

3. **Robust Error Handling:**
   - Handles Chrome Debug Protocol rejection of string IDs
   - Proper timeout mechanisms for WebSocket operations
   - Clean error messages and diagnostic information

## 🚀 HOW TO FIX:

### Option A: Replace Current Server (Recommended)
```bash
# 1. Stop current MCP server (if running)
# 2. Backup current server
cp mcp_server.py mcp_server_backup.py

# 3. Replace with fixed version
cp mcp_server_fixed.py mcp_server.py

# 4. Restart Claude Desktop to reload the server
```

### Option B: Run Fixed Server on Different Port
```bash
# Run fixed server on port 8001
python mcp_server_fixed.py --port 8001

# Add to Claude Desktop config:
{
  "mcpServers": {
    "cursor-dev-assistant-fixed": {
      "url": "http://127.0.0.1:8001/mcp"
    }
  }
}
```

## 🧪 TESTING THE FIXES:

### Test 1: JavaScript Execution
```python
# Before fix: Returns "Unexpected response format"
execute_javascript('console.log("test"); return "success";', tab_id)

# After fix: Should return successful execution result
execute_javascript_fixed('console.log("test"); return "success";', tab_id)
```

### Test 2: Console Monitoring  
```python
# 1. Start monitoring
start_console_monitoring_fixed(tab_id)

# 2. Generate console logs
execute_javascript_fixed('console.log("Real-time test!");', tab_id)

# 3. Check logs (should now show the console.log output)
get_console_logs(tab_id)
```

## 📋 VERIFICATION CHECKLIST:

- [ ] `mcp_server_version()` shows updated version info
- [ ] `execute_javascript_fixed()` returns success without "Unexpected response format" 
- [ ] `start_console_monitoring_fixed()` establishes real-time monitoring
- [ ] `get_console_logs()` captures actual console.log output
- [ ] Console logs appear in real-time as JavaScript executes

## 🔧 DEPENDENCIES:

Make sure you have the required dependencies:
```bash
pip install fastmcp uvicorn websockets aiohttp pychrome requests
```

## 🎯 QUICK START WITH FIXES:

1. **Use the fixed server:**
   ```bash
   python mcp_server_fixed.py --stdio
   ```

2. **Test the functionality:**
   ```python
   # Connect to Chrome
   connect_to_chrome()
   
   # Get available tabs  
   tabs = get_chrome_tabs()
   tab_id = tabs['tabs'][0]['id']
   
   # Start real-time monitoring
   start_console_monitoring_fixed(tab_id)
   
   # Execute JavaScript and see it work
   execute_javascript_fixed('console.log("🎉 Fixed!"); return "success";', tab_id)
   
   # Check captured logs
   get_console_logs(tab_id)
   ```

The fixed version addresses all the identified issues and provides proper Chrome Debug Protocol integration with real-time console monitoring and reliable JavaScript execution.

```


### File: AGENTS.md
### Description: AI agents documentation
### Lines:      288
### Size:  12K

```markdown
# AI Agents & Tools for Plasmo Extension Development

## Overview
This project integrates multiple AI-powered tools and agents to enhance the development experience for Plasmo browser extensions. The primary integration is through an MCP (Model Context Protocol) server that provides Chrome Debug Protocol access to AI assistants.

## Available Agents & Tools

### 1. Cursor AI Assistant (Primary)
**Purpose**: Main development assistant with full project context
**Capabilities**:
- Code generation and refactoring
- Real-time extension debugging through MCP server
- Chrome Debug Protocol integration
- Console log monitoring and analysis
- Extension auto-reload management
- **NEW**: Continuous testing automation with file watching
- **NEW**: Multi-service coordination and health monitoring

**MCP Tools Available**:
- `connect_to_chrome()` - Establish debugging connection
- `get_chrome_tabs()` - List available browser tabs
- `get_chrome_debug_info()` - Comprehensive debug status
- `start_console_monitoring(tab_id)` - Begin log capture
- `get_console_logs()` - Retrieve captured logs
- `execute_javascript_fixed(code, tab_id)` - **Enhanced** reliable JavaScript execution with WebSocket filtering
- `set_breakpoint(url, line, tab_id)` - Set debugging breakpoints
- `launch_chrome_debug()` - Start Chrome with debugging enabled

### 2. FastMCP Server
**Purpose**: Bridge between AI assistants and Chrome Debug Protocol
**Location**: `mcp_server.py`
**Port**: `http://127.0.0.1:8000`

**Key Features**:
- Real-time Chrome debugging integration
- Extension service worker monitoring
- Console log aggregation
- JavaScript execution in browser context
- WebSocket connection management

**JSON Serialization**: All tools return JSON-safe data structures, handling complex Chrome Debug Protocol objects automatically.

### 3. Chrome Debug Protocol Interface
**Purpose**: Low-level browser automation and debugging
**Configuration**: 
- Debug port: `9222`
- Required flags: `--remote-debugging-port=9222 --remote-allow-origins=*`
- Launch script: `./launch-chrome-debug.sh`

### 4. Continuous Testing System **[NEW]**
**Purpose**: Automated test execution triggered by file changes
**Location**: `continuous_test_runner.py`
**Integration**: SocketIO server + Chrome Debug Protocol

**Key Features**:
- **File Monitoring**: Watches `.ts`, `.tsx`, `.js`, `.jsx`, `.html`, `.css`, `.py` files
- **Auto-Test Execution**: Triggers tests via CDP when files change
- **Real-time Results**: Sends test outcomes to SocketIO API
- **WebSocket Filtering**: Handles Chrome extension message noise
- **DevTools Conflict Resolution**: Ensures clean CDP environment

**Test Triggers**:
```python
# File patterns that trigger testing
WATCH_PATTERNS = [
    "*.ts", "*.tsx", "*.js", "*.jsx",  # JavaScript/TypeScript changes
    "*.html", "*.css",                  # UI changes  
    "*.py"                             # Backend changes
]

# Test commands executed via CDP
TEST_COMMANDS = {
    'frontend': 'await window.testRunner.run()',
    'ui': 'await window.validateUI()',
    'backend': 'await window.testBackendIntegration()'
}
```

### 5. Service Orchestration System **[NEW]**
**Purpose**: Coordinated management of development services
**Services**: MCP Server + SocketIO Server + Plasmo Dev + Continuous Testing
**Configuration**: `.vscode/tasks.json` with auto-start on workspace open

**Service Architecture**:
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   MCP Server    │    │ SocketIO Server │    │   Plasmo Dev    │
│   Port: 8000    │    │   Port: 3001    │    │  Auto-reload    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │ Continuous Test │
                    │    Runner       │
                    │  File Watcher   │
                    └─────────────────┘
```

## Workflow Integration

### Extension Development Cycle
1. **Start Chrome**: Use `launch_chrome_debug()` or run `./launch-chrome-debug.sh`
2. **Connect MCP**: AI assistant connects via `connect_to_chrome()`
3. **Monitor Extension**: Use `start_console_monitoring()` for real-time logs
4. **Debug Issues**: Execute JavaScript, set breakpoints, analyze logs
5. **Auto-reload**: Extension rebuilds and reloads automatically on file changes

### AI-Assisted Debugging
The AI assistant can:
- Analyze console logs for errors and patterns
- Suggest fixes based on Chrome Debug Protocol data
- Execute diagnostic JavaScript in extension context
- Monitor extension lifecycle events
- Track service worker registration and updates

### Code Analysis & Generation
- **Context-aware**: AI has full access to extension source code
- **Real-time feedback**: Immediate testing through Chrome debug tools
- **Auto-correction**: AI can identify and fix common extension issues
- **Performance monitoring**: Track extension metrics through debug tools

## Setup Instructions

### For AI Assistants
1. Ensure MCP server is running: `./start_mcp.sh`
2. Connect to Chrome debug session
3. Use available MCP tools for debugging and monitoring
4. Restart Cursor if MCP tools are not available

### For Developers
1. Install dependencies: `pip install -r requirements.txt`
2. Configure Cursor MCP integration (see `MCP_README.md`)
3. Launch Chrome with debugging: `./launch-chrome-debug.sh`
4. Start development with AI assistance enabled

## Best Practices

### For AI Interactions
- Use `get_chrome_debug_info()` first to understand current state
- Monitor console logs continuously during development
- Execute small test scripts to verify extension functionality
- Use parallel tool calls for efficiency when gathering multiple data points

### Error Handling
- Always check Chrome connection status before debugging operations
- Handle WebSocket timeouts gracefully
- Verify extension service worker is active before monitoring
- Account for service worker ID changes on Chrome restart

### Performance Considerations
- Limit console log retention to prevent memory issues
- Use targeted JavaScript execution rather than broad monitoring
- Clear logs periodically with `clear_console_logs()`
- Monitor multiple tabs selectively based on development needs

## Advanced Features

### Extension Service Worker Debugging
- Automatic detection of Plasmo extension service workers
- Real-time console log streaming
- JavaScript injection for runtime diagnostics
- Breakpoint setting in extension code

### Multi-tab Development
- Support for debugging multiple browser tabs simultaneously
- Tab-specific console log filtering
- Cross-tab extension testing capabilities
- Coordinated debugging across extension contexts

### Automated Testing Integration
- AI-generated test scenarios based on extension behavior
- Automated console log analysis for error detection
- Performance metric collection through debug tools
- Regression testing through Chrome automation

## Critical Learnings & Best Practices **[NEW]**

### WebSocket Message Filtering
**Problem**: Chrome extensions flood CDP WebSocket with contextual messages, causing command timeouts
**Solution**: Filter messages by command ID and ignore extension noise

```python
# CRITICAL: Use command-specific message filtering
async def execute_reliable_cdp(websocket, command):
    command_id = int(time.time() * 1000)  # Unique ID
    command['id'] = command_id
    
    # Send command
    await websocket.send(json.dumps(command))
    
    # Listen ONLY for our command response
    while True:
        message = await websocket.recv()
        data = json.loads(message)
        
        # IGNORE extension noise - only process our command
        if data.get('id') == command_id:
            return data.get('result')
        # Continue listening, ignore other messages
```

### DevTools Interference Prevention
**Problem**: DevTools open on same tab blocks external CDP operations
**Solution**: Always check and close DevTools before CDP automation

```python
# CRITICAL: Ensure DevTools is closed before CDP operations
def ensure_clean_cdp_environment(tab_id):
    """
    DevTools and external CDP cannot operate on same tab simultaneously.
    Must close DevTools before running automated tests.
    """
    # Check if DevTools is attached
    # Close DevTools if open
    # Wait for clean state
    # Proceed with CDP operations
```

### Extension Context Noise Patterns
Common extension events that flood WebSocket (IGNORE these):
- `Runtime.executionContextCreated`
- `Runtime.executionContextDestroyed`
- `Page.frameNavigated`
- `Network.requestWillBeSent`
- `Network.responseReceived`

### Continuous Testing Integration
**Workflow**: File change → Test trigger → CDP execution → Real-time results
```
File Watcher → Debounce → CDP Test → SocketIO API → Web UI Update
```

**Test Execution Pattern**:
1. File change detected
2. Wait for debounce period (1-3 seconds)
3. Ensure clean CDP environment (close DevTools)
4. Execute test command via filtered WebSocket
5. Parse results and send to SocketIO API
6. Update real-time web interface

## Troubleshooting

### Common Issues
- **MCP connection failed**: Check if server is running on port 8000
- **Chrome debug unavailable**: Verify Chrome launched with debug flags
- **Extension not found**: Ensure extension is loaded and service worker is active
- **WebSocket errors**: Check `--remote-allow-origins=*` flag is set
- **🆕 CDP command timeouts**: Ensure message filtering by command ID is implemented
- **🆕 "Failed to enable Runtime domain"**: Close DevTools on target tab before CDP operations
- **🆕 Extension message noise**: Filter WebSocket messages, ignore extension context events
- **🆕 Test runner not triggering**: Check file watcher patterns and service dependencies

### Advanced Debugging
```bash
# Check WebSocket message flow (shows extension noise)
curl -N -H "Connection: Upgrade" -H "Upgrade: websocket" ws://localhost:9222/devtools/page/[TAB_ID]

# Verify all services are running
./check_services.sh

# Monitor continuous testing logs
tail -f logs/continuous_testing.log

# Test CDP connection manually
python3 quick_cdp_test.py

# Check service health endpoints
curl http://localhost:8000/health  # MCP Server
curl http://localhost:3001/api/status  # SocketIO Server
```

### Service Coordination Issues
```bash
# If services fail to start in correct order
./stop_all_services.sh
sleep 2
./start_all_services.sh

# Check service dependencies
./check_services.sh

# View service startup logs
tail -f logs/mcp_server.log
tail -f logs/socketio_server.log  
tail -f logs/continuous_testing.log
```

This integration provides a powerful development environment where AI assistants have direct access to browser debugging capabilities, enabling sophisticated extension development and troubleshooting workflows. ./
```



=================================================================================
= TEST FILES
=================================================================================


### File: test_dual_mode.py
### Description: MCP dual mode testing
### Lines:      151
### Size: 8.0K

```python
#!/usr/bin/env python3
"""
Test script to demonstrate dual-mode MCP server functionality
"""

import subprocess
import time
import json
import sys
import threading
from pathlib import Path

def test_http_mode():
    """Test the server in HTTP mode"""
    print("🖥️  Testing HTTP Mode...")
    print("=" * 40)
    
    # Start server in HTTP mode
    server_process = subprocess.Popen(
        [sys.executable, "mcp_server.py", "--port", "8001"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    
    # Wait for server to start
    time.sleep(3)
    
    try:
        # Test if server is running
        import requests
        try:
            response = requests.get("http://127.0.0.1:8001/mcp", timeout=5)
            print(f"✅ HTTP server is running on port 8001")
            print(f"   Status code: {response.status_code}")
        except requests.exceptions.RequestException as e:
            print(f"❌ HTTP server test failed: {e}")
    except ImportError:
        print("⚠️  requests library not available, skipping HTTP test")
    
    # Stop server
    server_process.terminate()
    server_process.wait()
    print("🛑 HTTP server stopped\n")

def test_stdio_mode():
    """Test the server in STDIO mode"""
    print("📟 Testing STDIO Mode...")
    print("=" * 40)
    
    # Start server in STDIO mode
    server_process = subprocess.Popen(
        [sys.executable, "mcp_server.py", "--stdio"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    # Send a simple MCP initialization message
    init_message = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "protocolVersion": "2024-11-05",
            "capabilities": {},
            "clientInfo": {
                "name": "test-client",
                "version": "1.0.0"
            }
        }
    }
    
    try:
        # Send message
        server_process.stdin.write(json.dumps(init_message) + "\n")
        server_process.stdin.flush()
        
        # Wait for response
        time.sleep(2)
        
        # Check if process is still alive (good sign)
        if server_process.poll() is None:
            print("✅ STDIO server is running and accepting input")
            print("   Process is alive and listening on stdin/stdout")
        else:
            print("❌ STDIO server exited unexpectedly")
            stderr = server_process.stderr.read()
            if stderr:
                print(f"   Error: {stderr}")
    
    except Exception as e:
        print(f"❌ STDIO server test failed: {e}")
    
    # Stop server
    server_process.terminate()
    server_process.wait()
    print("🛑 STDIO server stopped\n")

def test_command_line_args():
    """Test command line argument parsing"""
    print("⚙️  Testing Command Line Arguments...")
    print("=" * 40)
    
    # Test help
    result = subprocess.run([sys.executable, "mcp_server.py", "--help"], 
                          capture_output=True, text=True)
    if result.returncode == 0:
        print("✅ --help argument works")
    else:
        print("❌ --help argument failed")
    
    # Test invalid arguments
    result = subprocess.run([sys.executable, "mcp_server.py", "--invalid"], 
                          capture_output=True, text=True)
    if result.returncode != 0:
        print("✅ Invalid arguments are properly rejected")
    else:
        print("❌ Invalid arguments not rejected")
    
    print()

def main():
    """Run all tests"""
    print("🚀 FastMCP Dual-Mode Server Test")
    print("=" * 50)
    print()
    
    # Check if server file exists
    if not Path("mcp_server.py").exists():
        print("❌ mcp_server.py not found in current directory")
        sys.exit(1)
    
    # Test command line args first
    test_command_line_args()
    
    # Test HTTP mode
    test_http_mode()
    
    # Test STDIO mode  
    test_stdio_mode()
    
    print("🎉 All tests completed!")
    print()
    print("📝 Summary:")
    print("   • HTTP mode: Perfect for Cursor IDE and web deployments")
    print("   • STDIO mode: Perfect for Claude Desktop and local tools")
    print("   • Both modes support all the same MCP tools")
    print("   • Chrome Debug Protocol works in both modes")

if __name__ == "__main__":
    main() 
```



=================================================================================
= ASSETS AND BUILD INFORMATION
=================================================================================

### Assets Directory Structure
```
assets/icon.png
```

### Package.json Dependencies
```json
{
  "express": "^5.1.0",
  "plasmo": "0.90.5",
  "react": "18.2.0",
  "react-dom": "18.2.0",
  "socket.io": "^4.8.1",
  "socket.io-client": "^4.7.2"
}
{
  "@types/chrome": "0.0.246",
  "@types/node": "20.5.9",
  "@types/react": "18.2.21",
  "@types/react-dom": "18.2.7",
  "nodemon": "^3.1.10",
  "prettier": "^3.0.0",
  "typescript": "5.2.2"
}
```


=================================================================================
= GIT REPOSITORY INFORMATION
=================================================================================

### Git Status
```
 M bolt_automation_mcp.py
 M generate_llm_context.sh
 M launch-chrome-debug.sh
 M plasmo_repository_context.txt
?? bolt_automation_button_trick.py
?? bolt_automation_trusted_events.py
?? contents/bolt-automation.ts
?? simple_execcommand_test.js
```

### Recent Commits
```
aae7803 cleanup: remove unnecessary files and add Playwright automation attempt - Removed test_temp_mcp/, test_chrome_simple.py, chrome_debug_fixes.py, test_mcp_protocol.py - Added bolt_automation_playwright.py (Playwright approach with shared worker issues) - Current working solution: bolt_automation_mcp.py with Chrome Debug Protocol integer ID fix
fa3546c docs: embed Chrome Debug Protocol integer ID requirement - Update CHROME_DEBUG_SOLUTION.md to reflect fix status - Add critical rule about integer request IDs to .cursorrules - Update MCP_README.md to show working Chrome debugging - Add detailed code comments explaining the requirement
9b1cce5 fix: Chrome Debug Protocol requires integer request IDs - Change request_id from string UUID to integer timestamp - Fix 'Message must have integer id property' error - Add enhanced logging for event vs response debugging - Enable proper JavaScript execution in Chrome tabs via MCP server
facc6f5 Fix MCP server daemon persistence - Fix shebang formatting in start_all_services.sh - Implement double-fork daemon pattern for MCP server - MCP server now survives script termination when run as VS Code task - Add nohup and disown for other services for better independence - Server accessible at http://localhost:8000/mcp for Cursor integration
cbe4340 docs: Add critical learnings about CDP WebSocket filtering, DevTools interference, and continuous testing workflows to cursor rules and AGENTS.md + comprehensive repository context
641928e docs: Update .gitignore and cursor rules for development workflow cleanup
669d333 feat: Add utility scripts for MCP testing, Cursor IDE control, and extension configuration
b213415 feat: Add SocketIO integration and enhanced popup UI for Cursor IDE control with native messaging, real-time status, and debugging features
739f332 feat: Implement comprehensive continuous testing system with Chrome Debug Protocol integration
6e78053 fix: Update auto-start configuration to use correct MCP server filename - Fix .vscode/tasks.json references from mcp_server_consolidated.py to mcp_server.py - Update cursor rules to reference correct server file - Update documentation with proper filenames - Resolves auto-start issues caused by outdated file references after server consolidation
```

### Git Remote
```
origin	https://github.com/eldrgeek/Plasmo.git (fetch)
origin	https://github.com/eldrgeek/Plasmo.git (push)
```


=================================================================================
= END OF REPOSITORY CONTEXT
=================================================================================

Generated on: Sun Jun  8 12:00:10 EDT 2025
Total files processed: 39
Repository size: 3.6G
